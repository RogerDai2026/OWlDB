
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>auth: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/RICE-COMP318-FALL24/owldb-p1group24/auth/auth.go (85.5%)</option>
				
				<option value="file1">github.com/RICE-COMP318-FALL24/owldb-p1group24/concurrentSkipList/concurrentSkipList.go (89.9%)</option>
				
				<option value="file2">github.com/RICE-COMP318-FALL24/owldb-p1group24/db/db.go (100.0%)</option>
				
				<option value="file3">github.com/RICE-COMP318-FALL24/owldb-p1group24/db/dbcols.go (95.9%)</option>
				
				<option value="file4">github.com/RICE-COMP318-FALL24/owldb-p1group24/db/dbdocs.go (83.2%)</option>
				
				<option value="file5">github.com/RICE-COMP318-FALL24/owldb-p1group24/document/collection.go (81.8%)</option>
				
				<option value="file6">github.com/RICE-COMP318-FALL24/owldb-p1group24/document/docHelpers.go (88.2%)</option>
				
				<option value="file7">github.com/RICE-COMP318-FALL24/owldb-p1group24/document/document.go (100.0%)</option>
				
				<option value="file8">github.com/RICE-COMP318-FALL24/owldb-p1group24/jsondata/jsonvalue.go (85.7%)</option>
				
				<option value="file9">github.com/RICE-COMP318-FALL24/owldb-p1group24/jsondata/visitor.go (73.7%)</option>
				
				<option value="file10">github.com/RICE-COMP318-FALL24/owldb-p1group24/logger/logger.go (0.0%)</option>
				
				<option value="file11">github.com/RICE-COMP318-FALL24/owldb-p1group24/main.go (0.0%)</option>
				
				<option value="file12">github.com/RICE-COMP318-FALL24/owldb-p1group24/mocks/mocks.go (100.0%)</option>
				
				<option value="file13">github.com/RICE-COMP318-FALL24/owldb-p1group24/patcher/patch_visitor.go (85.0%)</option>
				
				<option value="file14">github.com/RICE-COMP318-FALL24/owldb-p1group24/patcher/patcher.go (80.0%)</option>
				
				<option value="file15">github.com/RICE-COMP318-FALL24/owldb-p1group24/resourceCreatorService/resourceCreatorService.go (78.4%)</option>
				
				<option value="file16">github.com/RICE-COMP318-FALL24/owldb-p1group24/resourceDeleterService/resourceDeleterService.go (100.0%)</option>
				
				<option value="file17">github.com/RICE-COMP318-FALL24/owldb-p1group24/resourceGetterService/resourceGetterService.go (81.2%)</option>
				
				<option value="file18">github.com/RICE-COMP318-FALL24/owldb-p1group24/resourcePatcherService/resourcePatcherService.go (100.0%)</option>
				
				<option value="file19">github.com/RICE-COMP318-FALL24/owldb-p1group24/server/authandlers.go (70.5%)</option>
				
				<option value="file20">github.com/RICE-COMP318-FALL24/owldb-p1group24/server/createhandlers.go (64.3%)</option>
				
				<option value="file21">github.com/RICE-COMP318-FALL24/owldb-p1group24/server/deletehandlers.go (66.7%)</option>
				
				<option value="file22">github.com/RICE-COMP318-FALL24/owldb-p1group24/server/gethandlers.go (52.7%)</option>
				
				<option value="file23">github.com/RICE-COMP318-FALL24/owldb-p1group24/server/server.go (100.0%)</option>
				
				<option value="file24">github.com/RICE-COMP318-FALL24/owldb-p1group24/server/serverutils.go (91.8%)</option>
				
				<option value="file25">github.com/RICE-COMP318-FALL24/owldb-p1group24/subscriptionManager/ColSubscriptionManager.go (63.9%)</option>
				
				<option value="file26">github.com/RICE-COMP318-FALL24/owldb-p1group24/subscriptionManager/Messager.go (100.0%)</option>
				
				<option value="file27">github.com/RICE-COMP318-FALL24/owldb-p1group24/subscriptionManager/subscriptionManager.go (100.0%)</option>
				
				<option value="file28">github.com/RICE-COMP318-FALL24/owldb-p1group24/validation/validator.go (76.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package auth

import (
        "crypto/rand"
        "encoding/base64"
        "encoding/json"
        "errors"
        "fmt"
        "github.com/RICE-COMP318-FALL24/owldb-p1group24/index_utils"
        "log/slog"
        "os"
        "time"
)

// TokenIndex defines an interface for managing tokens and their associated users.
// It provides methods to find, insert, update, and remove tokens.
type TokenIndex[token string, user Session] interface {
        Find(t token) (u user, found bool)
        Upsert(t token, check index_utils.UpdateCheck[string, Session]) (updated bool, err error)
        Remove(t token) (removedUser user, removed bool)
}

// UserIndex defines an interface for managing users and their associated tokens.
// It provides methods to find, insert, update, and remove users.
type UserIndex[user string, token Session] interface {
        Find(t user) (u token, found bool)
        Upsert(t user, check index_utils.UpdateCheck[string, Session]) (updated bool, err error)
        Remove(t user) (removedToken token, removed bool)
}

// Session holds the token and expiration information for an authenticated user.
type Session struct {
        user       string // Bearer token
        expiration int64  // Unix timestamp for expiration
}

// AuthStruct is responsible for managing user sessions and their corresponding tokens.
// It contains indexes to map users to tokens and vice versa.
type AuthStruct struct {
        // Map of users to tokens
        tokenToUser TokenIndex[string, Session] // Map of tokens to users
}

// New initializes a new AuthStruct by loading existing tokens from a file.
// If the token file is malformed or cannot be loaded, it returns a new AuthStruct
// with empty token and user mappings.
func New(tokenToUserMap TokenIndex[string, Session], tokenFile string) *AuthStruct <span class="cov8" title="1">{

        data, err := os.ReadFile(tokenFile)
        if err != nil </span><span class="cov8" title="1">{
                slog.Warn("Token file failed to load")
                return &amp;AuthStruct{tokenToUser: tokenToUserMap}
        }</span>

        <span class="cov8" title="1">tokens := make(map[string]string)
        err = json.Unmarshal(data, &amp;tokens)
        if err != nil </span><span class="cov8" title="1">{ //loading tokens
                slog.Warn("Malformed token json detected")
                return &amp;AuthStruct{tokenToUser: tokenToUserMap}
        }</span>
        <span class="cov8" title="1">for user, token := range tokens </span><span class="cov8" title="1">{
                tokenToUserMap.Upsert(token, func(string, Session, bool) (Session, error) </span><span class="cov8" title="1">{
                        return Session{user: user, expiration: time.Now().AddDate(0, 0, 1).Unix()}, nil
                }</span>)

        }

        <span class="cov8" title="1">return &amp;AuthStruct{tokenToUser: tokenToUserMap}</span>
}

// CreateSession generates a new session for the specified username.
// If the username is empty or the user already has a valid session, it returns an error.
// A randomly generated token is created with a 1-hour expiration time.
func (a *AuthStruct) CreateSession(username string) (string, error) <span class="cov8" title="1">{

        // Ensure the username is not empty
        if username == "" </span><span class="cov0" title="0">{
                slog.Error("Failed to create session: username is empty")
                return "", errors.New("username is empty")
        }</span>

        // Generate a random token
        <span class="cov8" title="1">token, err := randomGeneratedToken()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Error generating token", slog.String("user", username), slog.String("error", err.Error()))
                return "", errors.New("failed to generate token")
        }</span>

        // Store the token and expiration in the users map with the user as the key

        <span class="cov8" title="1">check2 := func(key string, val Session, exists bool) (newVal Session, err error) </span><span class="cov8" title="1">{
                return Session{user: username, expiration: time.Now().Add(time.Hour).Unix()}, nil
        }</span>
        <span class="cov8" title="1">a.tokenToUser.Upsert(token, check2)
        // Log session creation
        slog.Info("Session created", slog.String("user",
                username), slog.String("token", token))

        // Return the token and no error
        return token, nil</span>
}

// ValidateSession checks if the provided token is valid and still active.
// It returns the associated username if the session is valid, otherwise it returns an error.
func (a *AuthStruct) ValidateSession(token string) (string, error) <span class="cov8" title="1">{
        // Search for the token in all userToToken
        var sessionValid bool

        user, found := a.tokenToUser.Find(token)

        if !found </span><span class="cov8" title="1">{
                return "", fmt.Errorf("Missing or invalid bearer token")
        }</span>

        <span class="cov8" title="1">sessionValid = time.Now().Unix() &lt; user.expiration

        if !sessionValid </span><span class="cov0" title="0">{
                slog.Error("Session validation failed: token not found", slog.String("token", token))
                return "", fmt.Errorf("Missing or invalid bearer token")
        }</span>
        <span class="cov8" title="1">slog.Debug(fmt.Sprintf("User retrieved: %s", user.user))
        // Session is valid
        slog.Info("Session is valid", slog.String("token", token))
        return user.user, nil</span>
}

// Login creates or refreshes a session for the specified user.
// If a session exists, it is refreshed with a new expiration time. A new token is generated otherwise.
func (a *AuthStruct) Login(username string) (string, error) <span class="cov8" title="1">{

        token, err := randomGeneratedToken()

        userCheck := func(key string, curVal Session, exists bool) (newVal Session, err error) </span><span class="cov8" title="1">{

                return Session{user: username, expiration: time.Now().Add(time.Hour).Unix()}, nil
        }</span>

        <span class="cov8" title="1">_, err = a.tokenToUser.Upsert(token, userCheck)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">slog.Info("Session created", slog.String("user", username), slog.String("token", token))
        return token, nil</span>
}

// A function to logout a session
func (a *AuthStruct) Logout(token string) (bool, error) <span class="cov8" title="1">{

        // Find the user associated with the token
        _, removed := a.tokenToUser.Remove(token)

        if !removed </span><span class="cov8" title="1">{
                return false, fmt.Errorf("missing or invalid bearer token")
        }</span>

        <span class="cov8" title="1">slog.Info("Session logged out", slog.String("token", token))
        return true, nil</span>
}

// randomGeneratedToken generates a cryptographically secure random token
// and encodes it as a URL-safe base64 string.
func randomGeneratedToken() (string, error) <span class="cov8" title="1">{
        // Generate 16 random bytes (128 bits)
        byteLength := 14 // 16 bytes * 8 bits/byte = 128 bits
        bytes := make([]byte, byteLength)

        // Read random bytes from crypto/rand (in standard library)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Encode the bytes into a safe URL string
        <span class="cov8" title="1">bearer_token := base64.URLEncoding.WithPadding(base64.NoPadding).EncodeToString(bytes)

        // Return
        return bearer_token, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// package concurrentSkipList implements a concurrent skip-list leveraging lazy synchronization for atomic updates and insertions
package concurrentSkipList

import (
        "cmp"
        "context"
        "fmt"
        "github.com/RICE-COMP318-FALL24/owldb-p1group24/index_utils"
        "log/slog"
        "math/rand/v2"
        "sync"
        "sync/atomic"
)

// node is the internal data structure used by Skiplist to store key-value pairs.
type node[K cmp.Ordered, V any] struct {
        mtx sync.Mutex //used for synchronization

        fullyLinked atomic.Bool //whether the node has been fully linked to its predecessors and successors

        marked atomic.Bool //whether the node has been marked for deletion

        key K //the key the node stores

        val V //the value the node stores

        nexts []atomic.Pointer[node[K, V]] //an array of pointers to the next nodes in the skiplist

        topLevel int //the highest level list at which the node exists

        beingUpdated atomic.Bool
}

// Skiplist implements an abstract set of key-value pairs, of type K and V respectively.
// This list employs lazy synchronization for concurrent operations.
type Skiplist[K cmp.Ordered, V any] struct {
        maxK K //maximum key value

        minK K //minimum key value

        head *node[K, V] //the head of the skiplist

        mutationCount atomic.Uint64 //Updated on every successful insert &amp; delete
}

// NewSL instantiates a skiplist, supporting keys whose value lies within the range
// minkey and maxkey (bounds exclusive). *NOTE: inserting a value with key greater than
// max will break this thing.
// Returns a pointer to the newly created skiplist
func NewSL[K cmp.Ordered, V any](minkey K, maxkey K) *Skiplist[K, V] <span class="cov8" title="1">{

        dummyHead := node[K, V]{}

        dummyHead.key = minkey

        dummyHead.nexts = make([]atomic.Pointer[node[K, V]], 8) //prealloc saves memory and space

        dummyHead.topLevel = 8

        dummyHead.marked.Store(false)

        dummyTail := node[K, V]{}

        dummyTail.key = maxkey

        dummyTail.nexts = make([]atomic.Pointer[node[K, V]], 8)

        dummyTail.marked.Store(false)

        dummyTail.topLevel = 8

        for i := 0; i &lt; 8; i++ </span><span class="cov8" title="1">{
                dummyHead.nexts[i].Store(&amp;dummyTail)
                dummyTail.nexts[i].Store(nil)
        }</span>

        <span class="cov8" title="1">var sl Skiplist[K, V] = Skiplist[K, V]{
                minK: minkey,
                maxK: maxkey,
                head: &amp;dummyHead,
        }

        return &amp;sl</span>

}

// getState prints out the keys and values found at every level of the skiplist
func (sl *Skiplist[K, V]) getState() <span class="cov8" title="1">{

        for curLevel := 8 - 1; curLevel &gt;= 0; curLevel -= 1 </span><span class="cov8" title="1">{

                cur := sl.head
                for cur != nil </span><span class="cov8" title="1">{
                        slog.Debug(fmt.Sprintf("%+v (%+v) ----", cur.key, cur.val))
                        cur = cur.nexts[curLevel].Load()
                }</span>
                <span class="cov8" title="1">slog.Debug(fmt.Sprintf("&lt;nil&gt;"))
                slog.Debug(fmt.Sprintf("LEVEL %d", curLevel))
                slog.Debug(fmt.Sprintf("\n"))</span>
        }
}

// find is an internal routine returning the level at which a node is found, and an array of predecessors and successors in the skipist
func (sl *Skiplist[K, V]) find(key K, preds []atomic.Pointer[node[K, V]], succs []atomic.Pointer[node[K, V]]) int <span class="cov8" title="1">{

        pred := sl.head

        levelFound := -1

        for curLevel := 8 - 1; curLevel &gt;= 0; curLevel -= 1 </span><span class="cov8" title="1">{

                curr := pred.nexts[curLevel].Load()

                for key &gt; curr.key </span><span class="cov8" title="1">{ //Traverse until we find a node

                        pred = curr

                        curr = pred.nexts[curLevel].Load()
                }</span>

                <span class="cov8" title="1">if levelFound == -1 &amp;&amp; key == curr.key </span><span class="cov8" title="1">{
                        slog.Debug(fmt.Sprintf("Found the node with key %+v, its highest level is %d \n", key, curLevel))
                        levelFound = curLevel
                }</span>

                <span class="cov8" title="1">preds[curLevel].Store(pred)
                succs[curLevel].Store(curr)</span>

        }
        <span class="cov8" title="1">return levelFound</span>

}

// randomLevel generates a random level within range for insertion into the skiplist
func randomLevel() int <span class="cov8" title="1">{
        return rand.IntN(8)
}</span>

// Upsert either updates or inserts into the skiplist, depending on the function check's behavior (defined by the user)
// Returns true if the operation was successful, and an error if the operation failed
func (sl *Skiplist[K, V]) Upsert(key K, check index_utils.UpdateCheck[K, V]) (updated bool, err error) <span class="cov8" title="1">{

        newNodeLevel := randomLevel()

        preds := make([]atomic.Pointer[node[K, V]], 8)

        succs := make([]atomic.Pointer[node[K, V]], 8)

        for </span><span class="cov8" title="1">{

                levelFound := sl.find(key, preds, succs)

                if levelFound != -1 </span><span class="cov8" title="1">{

                        foundNode := succs[levelFound].Load()

                        if !foundNode.marked.Load() </span><span class="cov8" title="1">{ //node is not marked

                                for !foundNode.fullyLinked.Load() </span>{<span class="cov0" title="0">
                                }</span>

                                <span class="cov8" title="1">slog.Debug(fmt.Sprintf("A node with this key exists: %+v \n", key))

                                foundNode.mtx.Lock()

                                newVal, err1 := check(foundNode.key, foundNode.val, true)

                                if err1 == nil </span><span class="cov8" title="1">{ //we proceed with the update
                                        //Prevents other upserts from updating this value

                                        foundNode.val = newVal

                                        foundNode.mtx.Unlock()
                                        slog.Debug(fmt.Sprintf("OLD VALUE IS %+v \n ", foundNode.val))
                                        slog.Debug(fmt.Sprintf("Our updated value should be %+v \n", newVal))
                                        sl.mutationCount.Add(1)
                                        return true, nil
                                }</span> else<span class="cov0" title="0"> { //we do not proceed with the update and return why
                                        foundNode.mtx.Unlock()
                                        return false, err1
                                }</span>
                        }
                        <span class="cov0" title="0">continue</span>

                }

                <span class="cov8" title="1">highestLocked := -1

                var pred, succ, lastLocked *node[K, V]

                valid := true
                lockLevel := 0
                for valid &amp;&amp; (lockLevel &lt; 8) </span><span class="cov8" title="1">{

                        pred = preds[lockLevel].Load()

                        succ = succs[lockLevel].Load()

                        if pred != lastLocked </span><span class="cov8" title="1">{ //Can't lock the same thing twice ;)
                                pred.mtx.Lock()
                                slog.Debug(fmt.Sprintf("Locked the node at level %d,with value %+v \n", lockLevel, pred.key))
                                highestLocked = lockLevel
                                lastLocked = pred
                        }</span>

                        <span class="cov8" title="1">valid = !pred.marked.Load() &amp;&amp; !succ.marked.Load() &amp;&amp; (pred.nexts[lockLevel].Load() == succ)
                        lockLevel += 1</span>
                }

                <span class="cov8" title="1">if !valid </span><span class="cov8" title="1">{

                        var lastUnlocked *node[K, V]
                        var predd *node[K, V]
                        for i := highestLocked; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                                predd = preds[i].Load()
                                if predd != lastUnlocked </span><span class="cov8" title="1">{
                                        predd.mtx.Unlock()
                                        //slog.Debug(fmt.Sprintf("Unlocked the node at level %d", lockLevel))
                                        lastUnlocked = predd
                                }</span>
                        }
                        <span class="cov8" title="1">continue</span>

                }
                <span class="cov8" title="1">var nullV V

                newVal, err2 := check(key, nullV, false)

                if err2 != nil </span><span class="cov8" title="1">{
                        var lastUnlocked *node[K, V]
                        var predd *node[K, V]
                        for i := highestLocked; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                                predd = preds[i].Load()
                                if predd != lastUnlocked </span><span class="cov8" title="1">{
                                        predd.mtx.Unlock()

                                        lastUnlocked = predd
                                }</span>
                        }
                        <span class="cov8" title="1">return false, err2</span>
                }
                <span class="cov8" title="1">newNode := &amp;node[K, V]{

                        key:      key,
                        val:      newVal,
                        nexts:    make([]atomic.Pointer[node[K, V]], newNodeLevel+1),
                        topLevel: newNodeLevel,
                }

                for level := 0; level &lt;= newNodeLevel; level++ </span><span class="cov8" title="1">{
                        newNode.nexts[level].Store(succs[level].Load())
                        preds[level].Load().nexts[level].Store(newNode)
                }</span>

                <span class="cov8" title="1">newNode.fullyLinked.Store(true)
                //UNLOCKING
                var lastUnlocked *node[K, V]
                var predd *node[K, V]
                for i := highestLocked; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                        predd = preds[i].Load()
                        if predd != lastUnlocked </span><span class="cov8" title="1">{

                                //slog.Debug(fmt.Sprintf("unlocking at level %d ,node value is %+v \n", i, predd.key))
                                predd.mtx.Unlock()
                                lastUnlocked = predd
                        }</span>
                }
                <span class="cov8" title="1">sl.mutationCount.Add(1)
                return true, nil</span>

        }

}

// Find gets the value associated with key k.
// Returns the value and true if the key exists, otherwise returns the zero value of V and false
func (sl *Skiplist[K, V]) Find(key K) (V, bool) <span class="cov8" title="1">{
        preds := make([]atomic.Pointer[node[K, V]], 8)
        succs := make([]atomic.Pointer[node[K, V]], 8)
        var nullV V
        foundLevel := sl.find(key, preds, succs)
        if foundLevel == -1 </span><span class="cov8" title="1">{
                return nullV, false
        }</span>
        <span class="cov8" title="1">found := succs[foundLevel].Load()
        for found.beingUpdated.Load() </span>{<span class="cov0" title="0">
        }</span>
        <span class="cov8" title="1">return found.val, found.fullyLinked.Load() &amp;&amp; !found.marked.Load()</span>
}

// Remove removes the node with key K (if it exists)
// Returns the value of the removed node and true if the node was removed,
// otherwise returns the zero value of V and false
func (sl *Skiplist[K, V]) Remove(key K) (removedVal V, removed bool) <span class="cov8" title="1">{
        var nullV V
        var victim *node[K, V]
        topLevel := -1
        isMarked := false
        for </span><span class="cov8" title="1">{
                preds := make([]atomic.Pointer[node[K, V]], 8)
                succs := make([]atomic.Pointer[node[K, V]], 8)
                foundLevel := sl.find(key, preds, succs)

                if foundLevel != -1 </span><span class="cov8" title="1">{
                        victim = succs[foundLevel].Load()

                }</span>
                <span class="cov8" title="1">if !isMarked </span><span class="cov8" title="1">{

                        if foundLevel == -1 </span><span class="cov8" title="1">{
                                return nullV, false
                        }</span>

                        <span class="cov8" title="1">if !victim.fullyLinked.Load() </span><span class="cov0" title="0">{
                                return nullV, false
                        }</span>

                        <span class="cov8" title="1">if victim.marked.Load() </span><span class="cov0" title="0">{
                                return nullV, false
                        }</span>

                        <span class="cov8" title="1">if victim.topLevel != foundLevel </span><span class="cov0" title="0">{
                                return nullV, false
                        }</span>

                        <span class="cov8" title="1">topLevel = victim.topLevel
                        //slog.Debug(fmt.Sprintf("LOCKING THE VICTIM\n"))
                        victim.mtx.Lock()
                        //slog.Debug(fmt.Sprintf("LOCK SUCCESS\n"))
                        if victim.marked.Load() </span><span class="cov0" title="0">{
                                victim.mtx.Unlock()
                                return nullV, false
                        }</span>

                        <span class="cov8" title="1">victim.marked.Store(true)
                        isMarked = true</span>
                }
                //VICTIM FOUND, LOCK PREDECESSORS
                <span class="cov8" title="1">highestLocked := -1
                //slog.Debug(fmt.Sprintf("LOCKING PREDS\n"))

                level := 0

                valid := true
                var pred *node[K, V]
                var lastLocked *node[K, V]
                for valid &amp;&amp; (level &lt;= topLevel) </span><span class="cov8" title="1">{
                        pred = preds[level].Load()
                        if pred != lastLocked </span><span class="cov8" title="1">{

                                pred.mtx.Lock()
                                highestLocked = level
                                //slog.Debug(fmt.Sprintf("Locked node with value %+v\n", pred.key))
                                lastLocked = pred
                        }</span>

                        <span class="cov8" title="1">valid = !pred.marked.Load() &amp;&amp; (pred.nexts[level].Load() == victim)
                        level += 1</span>
                }
                <span class="cov8" title="1">if !valid </span><span class="cov0" title="0">{ //release all locks

                        unlockLevel := highestLocked
                        var lastUnlocked *node[K, V]
                        var predd *node[K, V]
                        for unlockLevel &gt;= 0 </span><span class="cov0" title="0">{
                                predd = preds[unlockLevel].Load()
                                if lastUnlocked != predd </span><span class="cov0" title="0">{
                                        predd.mtx.Unlock()
                                        lastUnlocked = predd
                                }</span>
                                <span class="cov0" title="0">unlockLevel -= 1</span>
                        }
                        <span class="cov0" title="0">continue</span>

                }

                <span class="cov8" title="1">unlinkLevel := topLevel

                for unlinkLevel &gt;= 0 </span><span class="cov8" title="1">{
                        preds[unlinkLevel].Load().nexts[unlinkLevel].Store(victim.nexts[unlinkLevel].Load())
                        unlinkLevel -= 1
                }</span>

                <span class="cov8" title="1">victim.mtx.Unlock()

                unlockLevel := highestLocked
                //slog.Debug(fmt.Sprintf("starting unlockLevel at %d\n", unlockLevel))
                var predNode *node[K, V]
                var lastUnlocked *node[K, V]
                for unlockLevel &gt;= 0 </span><span class="cov8" title="1">{
                        predNode = preds[unlockLevel].Load()
                        if predNode != lastUnlocked </span><span class="cov8" title="1">{
                                predNode.mtx.Unlock()

                                //slog.Debug(fmt.Sprintf("removed: unlocked node with value %+v\n", pred.key))
                                lastUnlocked = predNode
                        }</span>

                        <span class="cov8" title="1">unlockLevel -= 1</span>
                }
                <span class="cov8" title="1">sl.mutationCount.Add(1)
                return victim.val, true</span>

        }
}

// Query retrieves all key-value pairs in the range [lower,upper]
// Returns a slice of index_utils.Pair[K,V] and an error if the operation fails
func (sl *Skiplist[K, V]) Query(ctx context.Context, lower K, upper K) ([]index_utils.Pair[K, V], error) <span class="cov8" title="1">{

        var lastMutationCount uint64
        slog.Debug(fmt.Sprintf("entering query, lower bound is %+v,upper bound is %+v", lower, upper))
        for </span><span class="cov8" title="1">{ //retry until no mutations
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, fmt.Errorf("the request timed out")</span>
                default:<span class="cov8" title="1"></span>
                }
                <span class="cov8" title="1">lastMutationCount = sl.mutationCount.Load()
                resPair := make([]index_utils.Pair[K, V], 0)
                pred := sl.head
                iterkey := sl.minK
                //slog.Debug("in here now")
                for iterkey &lt;= upper </span><span class="cov8" title="1">{

                        curr := pred.nexts[0].Load()
                        iterkey = curr.key
                        if curr.key == sl.maxK </span><span class="cov8" title="1">{
                                break</span>
                        }
                        //slog.Debug(fmt.Sprintf("current key %+v \n", iterkey))
                        <span class="cov8" title="1">if ((lower &lt;= iterkey) &amp;&amp; (iterkey &lt; sl.maxK) &amp;&amp; (sl.minK &lt; iterkey)) &amp;&amp; curr.fullyLinked.Load() &amp;&amp; !curr.marked.Load() </span><span class="cov8" title="1">{
                                //slog.Debug(fmt.Sprintf("node with key %+v is in range!\n", iterkey))
                                pair := index_utils.Pair[K, V]{Key: curr.key, Value: curr.val}
                                resPair = append(resPair, pair)

                        }</span>
                        <span class="cov8" title="1">pred = curr

                        curr = pred.nexts[0].Load()
                        iterkey = curr.key</span>

                }

                <span class="cov8" title="1">mutCount := sl.mutationCount.Load()
                if mutCount == lastMutationCount </span><span class="cov8" title="1">{
                        slog.Debug("No mutations detected")
                        return resPair, nil
                }</span>
                <span class="cov0" title="0">lastMutationCount = mutCount
                slog.Debug("A mutation was detected, we will try again")</span>

        }

}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package db encapsulates the functionalities of the databases users can create. Note that a database is only functionally responsible for the top-level documents it holds.
package db

import (
        "context"
        "encoding/json"
        "github.com/RICE-COMP318-FALL24/owldb-p1group24/index_utils"
)

// DocumentAdder encapsulates the functionalities of the top-level documents with respect to adding new resources to the database
type DocumentAdder interface {
        AddChildDocument(docpath string, payload []byte, docname string, user string, overwrite bool, isPost bool, dbName string) ([]byte, int, string) //adds a child document
        AddChildCollection(colpath string, dbName string) ([]byte, int, string)                                                                         //adds a child collection
}

// DocumentDeleter encapsulates the functionalities of the top-level documents with respect to deleting resources the database
type DocumentGetter interface {
        GetChildDocument(docpath string, isSubscribe bool, dbName string) (payload []byte, status_code int, sub_id string, subChan *chan []byte, docEvent []byte)      //retrieves a document within the document
        GetChildCollection(colpath string, lo string, hi string, isSubscribe bool) (res []byte, stat_code int, subChan *chan []byte, subId string, docEvents [][]byte) // retrieves a collection within the document
        Notify(uri string, payload []byte, evType string)                                                                                                              // notifies all subscribers of a change
}

// DocumentDeleter encapsulates the functionalities of the top-level documents with respect to getting resources from the database
type DocumentDeleter interface {
        DeleteChildDocument(docpath string, dbName string) ([]byte, int) //deletes a child document
        DeleteChildCollection(colpath string) ([]byte, int)              //deletes a child collection
}

type DocumentPatcher interface {
        ApplyPatchDocument(dbName string, docPath string, patch []byte, user string) ([]byte, int) //applies a patch to a document
        DoPatch(patch []byte) ([]byte, error)                                                      //applies a patch to a document
        UpdateDoc(newRaw []byte, user string)                                                      //updates a document
}

// ColSubscriptionManager represents the contract necessary for the database's top-level collection to manage subscriptions
type ColSubscriptionManager interface {
        NotifyAll(colname string)                                             //notifies all subscribers of a change
        AddSubscriber(lo string, hi string) (subChan *chan []byte, id string) //adds a subscriber
        Notify(docname string, evType string, payload []byte)                 //notifies a subscriber of a change
        GenerateEvent(evType string, content []byte) []byte                   //generates an event
}
type Validator interface {
        Validate([]byte) error //validates a document
}

// DBDocumenter encapsulates the behaviors necessary for the top-level documents stored in the database.
// Note that the database is only responsible for actions performed on the top-most level of documents;
// for any children of said documents, the database delegates all functionality to the document itself
// to manage its children
type DBDocumenter interface {
        DocumentAdder
        DocumentGetter
        DocumentDeleter
        DocumentPatcher
        GetSerial() []byte
}

// DocIndex encompasses the behaviors needed for the indices in a document (pointing to collections)
type DocIndex[K string, V any] interface {
        Upsert(key K, check index_utils.UpdateCheck[K, V]) (updated bool, err error)             //Updates or inserts a a value
        Remove(key K) (removedValue V, removed bool)                                             //Removes a value
        Find(key K) (foundValue V, found bool)                                                   // Finds a value
        Query(ctx context.Context, start K, end K) (results []index_utils.Pair[K, V], err error) //Queries the index
}

// DocFactory is a factory function used to create documents
type DocFactory[T DBDocumenter] func(payload []byte, user string, path string) T

// Database represents a database object
type Database[K string, T DBDocumenter] struct {
        name string        //the name of the database
        dcf  DocFactory[T] // dcf creates documents that implement the container interface

        docs DocIndex[K, T] // docs holds documents

        colSubscriptionManager ColSubscriptionManager // colSubscriptionManager manages subscriptions

        validator Validator // validator validates documents
}

// New creates a database object
func New[K string, T DBDocumenter](name string, dcf DocFactory[T], index DocIndex[K, T], manager ColSubscriptionManager, v Validator) *Database[K, T] <span class="cov8" title="1">{
        db := Database[K, T]{}
        db.dcf = dcf
        db.name = name
        db.docs = index
        db.colSubscriptionManager = manager
        db.validator = v
        return &amp;db
}</span>

// NotifyAll notifies all subscribers to a DB that a database has been deleted
func (db *Database[K, T]) NotifyAll(colname string) <span class="cov8" title="1">{
        b, _ := json.Marshal("/")
        db.colSubscriptionManager.NotifyAll(string(b))
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package db provides methods for managing collections within a document-based database.
// It allows for retrieving, deleting, and uploading collections in a hierarchical structure.
package db

import (
        "context"
        "encoding/json"
        "fmt"
        "log/slog"
        "net/http"
        "strings"
        "time"
)

// GetColSerial retrieves and serializes the collection at the specified path.
// It returns a byte slice of the serialized collection, a status code, and an optional subscription channel if applicable.
// The range is defined by the 'lo' and 'hi' keys, and if isSubscription is true, the function will return events for document changes.
func (db *Database[K, T]) GetColSerial(colpath string, lo string, hi string, isSubscription bool) ([]byte, int, *chan []byte, string, [][]byte) <span class="cov8" title="1">{

        splitPath := strings.Split(colpath, "/")

        topDocName := splitPath[0] //get the name of the parent document

        if len(colpath) == 0 </span><span class="cov8" title="1">{ //TOP-LEVEL DATABASE GET
                res, stat := db.serialTop(lo, hi)
                if isSubscription </span><span class="cov8" title="1">{
                        docBytes := make([][]byte, 0)
                        subChan, subId := db.colSubscriptionManager.AddSubscriber(lo, hi)
                        ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(15*time.Second))
                        defer cancel()
                        docs, _ := db.docs.Query(ctx, K(lo), K(hi))
                        for _, v := range docs </span><span class="cov8" title="1">{
                                event := db.colSubscriptionManager.GenerateEvent("update", v.Value.GetSerial())
                                docBytes = append(docBytes, event)
                        }</span>
                        <span class="cov8" title="1">return res, stat, subChan, subId, docBytes</span>
                }

                <span class="cov8" title="1">return res, stat, nil, "", nil</span>
        }

        <span class="cov8" title="1">topDoc, found := db.docs.Find(K(topDocName)) //look for a doc with this name

        if !found </span><span class="cov8" title="1">{

                errmsg, _ := json.Marshal("Collection does not exist")

                return errmsg, http.StatusNotFound, nil, "", nil
        }</span>
        //delegated to the documents
        <span class="cov8" title="1">return topDoc.GetChildCollection(colpath, lo, hi, isSubscription)</span>

}

// DeleteCol deletes the collection located at the path colpath in the database.
// Returns a response (if an error occurred) and a status code.
func (db *Database[K, T]) DeleteCol(colpath string) ([]byte, int) <span class="cov8" title="1">{

        slog.Debug(fmt.Sprintf("Deleting the collection at path %+v", colpath))

        splitPath := strings.Split(colpath, "/")

        topDocName := splitPath[0] //get the parent document

        topDoc, found := db.docs.Find(K(topDocName)) //looking for the db

        if !found </span><span class="cov8" title="1">{

                errmsg, _ := json.Marshal("Collection does not exist")

                return errmsg, http.StatusNotFound
        }</span>
        <span class="cov8" title="1">return topDoc.DeleteChildCollection(colpath)</span>
}

// UploadCol uploads a collection at the path colpath, at the database dbName
// Returns a response (if an error occurred) and a status code.
func (db *Database[K, T]) UploadCol(colpath string, dbName string) ([]byte, int, string) <span class="cov8" title="1">{

        slog.Debug(fmt.Sprintf("UploadCol: uploading a collection at path %s,database name %s", colpath, dbName))

        splitPath := strings.Split(colpath, "/")

        topDocName := splitPath[0]

        topDoc, found := db.docs.Find(K(topDocName)) //find the top document

        if !found </span><span class="cov8" title="1">{ //we couldn't find it :(

                errmsg, _ := json.Marshal("Collection does not exist")

                return errmsg, http.StatusNotFound, ""
        }</span>
        <span class="cov8" title="1">return topDoc.AddChildCollection(colpath, dbName)</span>
}

// serialTop is an internal routine that returns a serialized representation of the top-level collection
// represented as a JSON-encoded byte slice. Also returns a status code
func (db *Database[K, T]) serialTop(lo string, hi string) ([]byte, int) <span class="cov8" title="1">{
        ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(10*time.Second))
        defer cancel()
        res, err := db.docs.Query(ctx, K(lo), K(hi)) //query on top-level collection
        if err != nil </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal(err.Error())
                return errmsg, http.StatusBadRequest
        }</span>
        <span class="cov8" title="1">resArr := []json.RawMessage{}
        for _, pair := range res </span><span class="cov8" title="1">{ //serializing all documents
                bytes := pair.Value.GetSerial()
                var rj json.RawMessage = bytes
                resArr = append(resArr, rj)
        }</span>
        <span class="cov8" title="1">resSerial, _ := json.Marshal(resArr)
        return resSerial, http.StatusOK</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package db provides functions for managing documents within a document-based database,
// including uploading, deleting, patching, and retrieving documents.
package db

import (
        "encoding/json"
        "fmt"
        "log/slog"
        "strings"

        "net/http"
)

// UploadDocument uploads a document to the database at the specified path.
// This function handles both PUT and POST requests. It supports options for overwriting
// an existing document and allows for top-level document management as well as child documents.
// Returns a serialized response, status code, and potential errors if the operation fails.
func (db *Database[K, T]) UploadDocument(docpath string, payload []byte, docname, user string, overwrite, isPost bool, dbName string) ([]byte, int, string) <span class="cov8" title="1">{

        slog.Debug(fmt.Sprintf("uploading document at path %+v to the database %s dbName, isPost is %t", docpath, dbName, isPost))

        stringPath := string(docpath)

        splitPath := strings.Split(stringPath, "/")

        if len(splitPath) == 1 </span><span class="cov8" title="1">{ //we are posting to the top DB
                return db.uploadTop(K(docpath), payload, docname, user, overwrite, isPost, dbName)
        }</span>

        <span class="cov8" title="1">topDocName := K(splitPath[0])

        parentDoc, found := db.docs.Find(topDocName)
        if !found </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal("Document does not exist")
                return errmsg, http.StatusNotFound, ""
        }</span>
        <span class="cov8" title="1">return parentDoc.AddChildDocument(stringPath, payload, docname, user, overwrite, isPost, dbName)</span>

}

// uploadTop uploads a document to the top level of the database.
// It creates a new document or overwrites an existing one depending on the overwrite flag.
// Returns a response indicating the result of the operation and the associated status code.
func (db *Database[K, T]) uploadTop(docpath K, payload []byte, docname string, user string, overwrite bool, isPost bool, dbName string) ([]byte, int, string) <span class="cov8" title="1">{

        slog.Debug(fmt.Sprintf("uploading to the top of database %+v, isPost %t", string(docpath), isPost))

        newDoc := db.dcf(payload, user, string(docpath))

        var nullDoc T
        var stat_code int
        check := func(docname K, curVal T, exists bool) (newVal T, err error) </span><span class="cov8" title="1">{
                if !exists </span><span class="cov8" title="1">{
                        stat_code = http.StatusCreated
                        db.colSubscriptionManager.Notify(string(docname), "update", newDoc.GetSerial())
                        newDoc.Notify(dbName+"/"+string(docname), newDoc.GetSerial(), "update")
                        return newDoc, nil
                }</span> else<span class="cov8" title="1"> { //the document exists
                        if !overwrite </span><span class="cov8" title="1">{
                                stat_code = http.StatusPreconditionFailed
                                return nullDoc, fmt.Errorf("document already exists")
                        }</span> else<span class="cov8" title="1"> {
                                stat_code = http.StatusOK
                                curVal.UpdateDoc(payload, user)
                                db.colSubscriptionManager.Notify(string(docname), "update", curVal.GetSerial())
                                curVal.Notify(db.name+"/"+string(docname), curVal.GetSerial(), "update")
                        }</span>
                }

                <span class="cov8" title="1">return curVal, nil</span>
        }

        <span class="cov8" title="1">_, err := db.docs.Upsert(K(docname), check)

        if err != nil </span><span class="cov8" title="1">{ //doc failed -
                var statCode int = 400
                if !isPost </span><span class="cov8" title="1">{
                        statCode = 412
                }</span>
                <span class="cov8" title="1">b, _ := json.Marshal(err.Error())
                return b, statCode, ""</span>
        }
        <span class="cov8" title="1">slog.Debug("AAAAAAAAAAAA")
        respJSON := struct {
                Uri string `json:"uri"`
        }{
                Uri: "/v1/" + dbName + "/" + string(docpath),
        }

        b, _ := json.Marshal(respJSON)

        //slog.Debug(fmt.Sprintf("Notifying subscribers of the topmost database about document %s", docname))

        return b, stat_code, respJSON.Uri</span>
}

// GetDocumentSerial retrieves and returns a serialized version of the document located at docpath.
// If isSubscribe is true, the function returns a channel for subscription to document changes.
// Returns the serialized payload, a subscription channel, subscription ID, status code, and any document events.
func (db *Database[K, T]) GetDocumentSerial(docpath string, isSubscribe bool) (payload []byte, subChannel *chan []byte, subId string, statusCode int, docEvent []byte) <span class="cov8" title="1">{

        slog.Debug(fmt.Sprintf("GetDocumentSerial,docpath is %s", docpath))

        splitPath := strings.Split(docpath, "/")

        topDocName := K(splitPath[0])

        topDoc, found := db.docs.Find(topDocName)

        if !found </span><span class="cov0" title="0">{

                errmsg, _ := json.Marshal("Document does not exist")

                return errmsg, nil, "", http.StatusNotFound, docEvent
        }</span>

        <span class="cov8" title="1">payload, statusCode, subId, subChannel, docEvent = topDoc.GetChildDocument(docpath, isSubscribe, db.name)
        return payload, subChannel, subId, statusCode, docEvent</span>
}

// DeleteDoc deletes the document at the specified path.
// This method can handle both top-level documents and child documents.
// Returns a serialized response and a status code indicating success or failure.
func (db *Database[K, T]) DeleteDoc(docpath string) ([]byte, int) <span class="cov8" title="1">{

        splitPath := strings.Split(docpath, "/")

        if len(splitPath) == 1 </span><span class="cov8" title="1">{
                return db.deleteTop(docpath)
        }</span>

        <span class="cov8" title="1">topDocName := K(splitPath[0])

        topDoc, found := db.docs.Find(topDocName)

        if !found </span><span class="cov8" title="1">{

                errmsg, _ := json.Marshal("Document does not exist")

                return errmsg, http.StatusNotFound
        }</span>
        //delegated to the documents
        <span class="cov8" title="1">return topDoc.DeleteChildDocument(docpath, db.name)</span>
}

// deleteTop handles the case where the topmost document must be deleted
func (db *Database[K, T]) deleteTop(docpath string) ([]byte, int) <span class="cov8" title="1">{

        slog.Debug(fmt.Sprintf("deleting the top document,resource path is %s", docpath))

        removedDoc, removed := db.docs.Remove(K(docpath))

        //This is the only way removes can fail
        if !removed </span><span class="cov8" title="1">{

                errmsg, _ := json.Marshal("Document does not exist")

                return errmsg, http.StatusNotFound
        }</span>

        <span class="cov8" title="1">payload := "/" + docpath
        b, _ := json.Marshal(payload)
        removedDoc.Notify(db.name+"/"+docpath, b, "delete")
        db.colSubscriptionManager.Notify(docpath, "delete", b)
        //success
        return nil, http.StatusNoContent</span>
}

// deleteTop handles the deletion of a top-level document.
// Returns a response and status code indicating the outcome of the operation.
func (db *Database[K, T]) Patch(docPath string, patches []byte, user string) ([]byte, int) <span class="cov8" title="1">{

        splitPath := strings.Split(docPath, "/")
        if len(splitPath) == 0 </span><span class="cov0" title="0">{
                return []byte(`{"error": "Invalid document path"}`), http.StatusBadRequest
        }</span>
        <span class="cov8" title="1">topDocName := K(splitPath[0])
        topDoc, found := db.docs.Find(topDocName)
        if !found </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal("Document does not exist")
                return errmsg, http.StatusNotFound
        }</span>
        <span class="cov8" title="1">if len(splitPath) == 1 </span><span class="cov8" title="1">{
                return db.patchTop(docPath, patches, user)
        }</span>

        <span class="cov8" title="1">slog.Debug(fmt.Sprintf("From Patch in db, user is %s", user))
        responseBytes, statusCode := topDoc.ApplyPatchDocument(db.name, docPath, patches, user)
        if statusCode != http.StatusOK </span><span class="cov0" title="0">{
                return responseBytes, statusCode
        }</span>
        <span class="cov8" title="1">return responseBytes, statusCode</span>
}

// Patch applies a JSON patch to the document at the specified path
func (db *Database[K, T]) patchTop(docName string, patch []byte, user string) ([]byte, int) <span class="cov8" title="1">{

        var nullDoc T
        var newDocPayload []byte
        slog.Debug(fmt.Sprintf("user is %s", user))
        chk := func(name K, curDoc T, exists bool) (newDoc T, err error) </span><span class="cov8" title="1">{ //guaranteed to be atomic due to locks in SL
                if !exists </span><span class="cov0" title="0">{
                        return nullDoc, fmt.Errorf("Document does not exist")
                }</span>

                <span class="cov8" title="1">newRaw, patchErr := curDoc.DoPatch(patch)
                if patchErr != nil </span><span class="cov0" title="0">{ //DO NOT UPDATE
                        slog.Debug("DO NOT UPDATE,WE GOT AN ERROR")
                        return nullDoc, patchErr
                }</span>
                <span class="cov8" title="1">err = db.validator.Validate(newRaw) //is this a valid patch?
                if err != nil </span><span class="cov0" title="0">{
                        return nullDoc, err
                }</span> //this will not update
                <span class="cov8" title="1">slog.Debug("About to update DOCUMENT SUBSCRIBERS")
                curDoc.UpdateDoc(newRaw, user)

                newDocPayload = curDoc.GetSerial() //serializing new documents
                curDoc.Notify(db.name+"/"+docName, newDocPayload, "update")
                db.colSubscriptionManager.Notify(docName, "update", newDocPayload)
                return curDoc, nil</span>
        }
        <span class="cov8" title="1">updated, er := db.docs.Upsert(K(docName), chk)

        msg := "patch applied"
        if !updated </span><span class="cov0" title="0">{

                if er.Error() == "Document does not exist" </span><span class="cov0" title="0">{
                        errmsg, _ := json.Marshal(er.Error())
                        return errmsg, http.StatusNotFound
                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(er.Error(), "bad patch operation") </span><span class="cov0" title="0">{
                        errmsg, _ := json.Marshal(er.Error())
                        return errmsg, http.StatusBadRequest
                }</span> else<span class="cov0" title="0"> {
                        msg = er.Error()
                }</span>
        } else <span class="cov8" title="1">{
        }</span>

        <span class="cov8" title="1">return generatePatchResponse(db.name, docName, !updated, msg), http.StatusOK</span>
}

// generatePatchResponse generates a response for a patch operation.
func generatePatchResponse(dbName string, docPath string, patchFailed bool, msg string) []byte <span class="cov8" title="1">{

        uri := "/v1/" + dbName + "/" + docPath

        response := struct {
                Uri         string `json:"uri"`
                PatchFailed bool   `json:"patchFailed"`
                Message     string `json:"string"`
        }{
                Uri:         uri,
                PatchFailed: patchFailed,
                Message:     msg,
        }

        b, err := json.Marshal(response)
        if err != nil </span><span class="cov0" title="0">{
                slog.Warn("WARNING from docHelpers: JSON marshaling failed!")
        }</span>
        <span class="cov8" title="1">return b</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package document

import (
        "context"
        "encoding/json"
        "github.com/RICE-COMP318-FALL24/owldb-p1group24/index_utils"
        "net/http"
)

// CollectionIndex encapsulates the behaviors needed for the Collection indices to function properly
// It is a generic interface that can be used to index any type of collection
type CollectionIndex[K string, V *Document] interface {
        Find(key K) (foundValue V, found bool)
        Query(ctx context.Context, low K, hi K) ([]index_utils.Pair[K, V], error)
        Upsert(key K, check index_utils.UpdateCheck[K, V]) (updated bool, err error)
        Remove(key K) (removedVal V, removed bool)
}

// ColSubscriptionManager is responsible for managing the subscriptions of a given collection. We inject it's
// implementation in main, so for now our Collection delegates to this interface
type ColSubscriptionManager interface {
        AddSubscriber(lo string, hi string) (subChan *chan []byte, id string) // Adds a subscriber
        Remove(id string)                                                     // Removes a subscriber
        Notify(docname string, evType string, payload []byte)                 // Notifies a subscriber of a change
        NotifyAll(colname string)
        GenerateEvent(evtype string, payload []byte) []byte // Notifies all subscribers of a change
}

// Collection encapsulates the functionalities associated with Collections
// We consider collections to be an internal property of documents
type Collection struct {
        Name                string                             //the name of the collection
        Docs                CollectionIndex[string, *Document] //the indices to other documents in the collection
        SubscriptionManager ColSubscriptionManager             //manages the subscriptions for a collection
}

// CSerialize serializes the documents of a collection whose name lies in the range [lo,hi].
// Returns a serialized representation of the collection, and a status code
func (c *Collection) CSerialize(ctx context.Context, lo string, hi string) ([]byte, int) <span class="cov8" title="1">{
        res, err := c.Docs.Query(ctx, lo, hi)
        if err != nil </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal(err.Error())
                return errmsg, http.StatusBadRequest
        }</span>
        <span class="cov8" title="1">resArr := []json.RawMessage{}
        for _, pair := range res </span><span class="cov8" title="1">{
                bytes := pair.Value.GetSerial()
                var rj json.RawMessage = bytes
                resArr = append(resArr, rj)
        }</span>
        <span class="cov8" title="1">resSerial, _ := json.Marshal(resArr)
        return resSerial, http.StatusOK</span>
}

// Creates a new collection
type Factory func(colName string) *Collection
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package document encompasses the functionalities and behaviors of document objects in OwlDB
package document

import (
        "context"
        "encoding/json"
        "fmt"
        "github.com/RICE-COMP318-FALL24/owldb-p1group24/jsondata"
        "log/slog"
        "net/http"
        "strings"
        "time"
)

// serialize returns a JSON-encoded byte slice containing the content of document d
// It is used to serialize the document for storage or transmission
func (d *Document) serialize() ([]byte, error) <span class="cov8" title="1">{

        var docJSON jsondata.JSONValue

        _ = json.Unmarshal(d.Info.Doc, &amp;docJSON)

        serialStruct := struct {
                Path string             `json:"path"`
                Doc  jsondata.JSONValue `json:"doc"`
                Meta metadata           `json:"meta"`
        }{
                Path: d.Info.Path,
                Doc:  docJSON,
                Meta: d.Info.Meta,
        }

        return json.Marshal(serialStruct)

}</span>

// GetSerial returns a serialized representation of the document contents
// as a JSON-encoded byte slice
func (d *Document) GetSerial() []byte <span class="cov8" title="1">{
        res, _ := d.serialize()
        return res
}</span>

// SubscriptionManagerFactory is a function type that creates a new SubscriptionManager
type SubscriptionManagerFactory func() SubscriptionManager

// AddChildDocument adds a child document at path docpath.
// payload: a raw
func (d *Document) AddChildDocument(docpath string, payload []byte, docname string, user string, overwrite bool, isPost bool, dbName string) ([]byte, int, string) <span class="cov8" title="1">{

        splitPath := strings.Split(docpath, "/")
        parentColName := splitPath[len(splitPath)-2]
        splitPathToParent := splitPath[:len(splitPath)-2]

        parentDoc, found := d.traverseDocuments(splitPathToParent)
        if !found </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal("Collection does not exist")
                return errmsg, http.StatusNotFound, ""
        }</span>
        <span class="cov8" title="1">parentCol, foundCol := parentDoc.collections.Find(parentColName)
        if !foundCol </span><span class="cov8" title="1">{
                errmsg, _ := json.Marshal("Collection does not exist")
                return errmsg, http.StatusNotFound, ""
        }</span>

        <span class="cov8" title="1">newDoc := New(payload, user, docpath, d.docCollectionFactory, d.collectionFactory, d.smFactory, d.validator, d.patcher, d.messager)
        var didOverwrite bool
        check := func(key string, curVal *Document, exists bool) (newVal *Document, err error) </span><span class="cov8" title="1">{

                if exists &amp;&amp; !overwrite </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("document already exists")
                }</span>
                <span class="cov8" title="1">if exists &amp;&amp; overwrite </span><span class="cov8" title="1">{
                        didOverwrite = true
                        curVal.UpdateDoc(payload, user)
                        slog.Debug("ABOUT TO NOTIFY ABOUT A PUT OVERWRITE")
                        curVal.messager.NotifyDocs(dbName+"/"+docpath, "update", curVal.GetSerial())
                        parentCol.SubscriptionManager.Notify(docname, "update", curVal.GetSerial())
                        return curVal, nil
                }</span>
                <span class="cov8" title="1">if isPost </span><span class="cov8" title="1">{
                        parentCol.SubscriptionManager.Notify(docname, "update", newDoc.GetSerial())
                        return newDoc, nil
                }</span>

                <span class="cov8" title="1">newDoc.messager.NotifyDocs(dbName+"/"+docpath, "update", newDoc.GetSerial())
                parentCol.SubscriptionManager.Notify(docname, "update", newDoc.GetSerial())
                return newDoc, nil</span>
        }

        //attempting to upsert
        <span class="cov8" title="1">_, err := parentCol.Docs.Upsert(docname, check)

        if err != nil </span><span class="cov8" title="1">{
                errmsg, _ := json.Marshal(err.Error())
                return errmsg, http.StatusPreconditionFailed, ""
        }</span>

        <span class="cov8" title="1">resp, uri := generatePutResponse(docpath, dbName)
        if didOverwrite </span><span class="cov8" title="1">{
                return resp, http.StatusOK, uri
        }</span>
        <span class="cov8" title="1">return resp, http.StatusCreated, uri</span>

}

// AddChildCollection adds an empty collection to the document at resourcepath colpath.
// Returns a JSON-encoded response object and a status code
func (d *Document) AddChildCollection(colpath string, dbName string) ([]byte, int, string) <span class="cov8" title="1">{
        slog.Debug(fmt.Sprintf("Adding a child collection with path %s", colpath))
        colpath = strings.TrimSuffix(colpath, "/")
        newSplitPath := strings.Split(colpath, "/")
        childColName := newSplitPath[len(newSplitPath)-1]
        parentDoc, found := d.traverseDocuments(newSplitPath[:len(newSplitPath)-1])
        if !found </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal("Collection does not exist")
                return errmsg, http.StatusNotFound, ""
        }</span>
        <span class="cov8" title="1">newCol := d.collectionFactory(childColName)
        check := func(key string, curVal *Collection, exists bool) (newVal *Collection, err error) </span><span class="cov8" title="1">{
                if exists </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("Collection Already Exists")
                }</span>
                <span class="cov8" title="1">return newCol, nil</span>

        }
        <span class="cov8" title="1">_, err := parentDoc.collections.Upsert(childColName, check)
        if err != nil </span><span class="cov8" title="1">{
                errmsg, _ := json.Marshal(err.Error())
                return errmsg, http.StatusBadRequest, ""
        }</span>
        <span class="cov8" title="1">resp, uri := generatePutResponse(colpath+"/", dbName)

        return resp, http.StatusCreated, uri</span>
}

// GetChildDocument retrieves a document contained in another document located at the forward-slash-delimited path.
// returns a JSON-encoded version of the document, and a status code
func (d *Document) GetChildDocument(docpath string, isSubscribe bool, dbName string) ([]byte, int, string, *chan []byte, []byte) <span class="cov8" title="1">{

        splitPath := strings.Split(docpath, "/")

        if len(splitPath) == 0 </span><span class="cov0" title="0">{ //returning itself

                if isSubscribe </span><span class="cov0" title="0">{
                        subChan, subId := d.messager.AddDocSubscriber(dbName + "/" + docpath)
                        return d.GetSerial(), http.StatusOK, subId, subChan, d.sm.GenerateEvent("update", d.GetSerial())
                }</span>

                <span class="cov0" title="0">return d.GetSerial(), http.StatusOK, "", nil, nil</span>
        }

        <span class="cov8" title="1">resDoc, found := d.traverseDocuments(splitPath)
        if !found </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal("Document does not exist")
                return errmsg, http.StatusNotFound, "", nil, nil
        }</span>

        <span class="cov8" title="1">payload := resDoc.GetSerial()

        if isSubscribe </span><span class="cov8" title="1">{

                ch, subId := resDoc.messager.AddDocSubscriber(dbName + "/" + docpath)
                return payload, http.StatusOK, subId, ch, resDoc.sm.GenerateEvent("update", payload)
        }</span>

        <span class="cov8" title="1">return payload, http.StatusOK, "", nil, nil</span>

}

// GetChildCollection gets a child collection belonging to the document d (or one of it's descendant documents). If
// this request is part of a subscription request, a channel and unique identifier will also be returned, and this
// will be used to provide future updates to the client
func (d *Document) GetChildCollection(colpath string, lo string, hi string, isSubscribe bool) ([]byte, int, *chan []byte, string, [][]byte) <span class="cov8" title="1">{
        colpath = strings.TrimSuffix(colpath, "/")
        newSplitPath := strings.Split(colpath, "/")
        childColName := newSplitPath[len(newSplitPath)-1]
        parentDoc, found := d.traverseDocuments(newSplitPath[:len(newSplitPath)-1])
        if !found </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal("Collection does not exist")
                return errmsg, http.StatusNotFound, nil, "", nil
        }</span>
        <span class="cov8" title="1">childCol, foundCol := parentDoc.collections.Find(childColName)
        if !foundCol </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal("Collection does not exist")
                return errmsg, http.StatusNotFound, nil, "", nil
        }</span>
        <span class="cov8" title="1">ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(10*time.Second))
        defer cancel()
        payload, stat := childCol.CSerialize(ctx, lo, hi)
        if isSubscribe </span><span class="cov8" title="1">{
                slog.Debug("Getting a new channel for this subscription request")
                subChan, subId := childCol.SubscriptionManager.AddSubscriber(lo, hi)
                ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(15*time.Second))
                defer cancel()
                docs, _ := childCol.Docs.Query(ctx, lo, hi)
                docBytes := make([][]byte, 0)
                for _, v := range docs </span><span class="cov0" title="0">{
                        event := childCol.SubscriptionManager.GenerateEvent("update", v.Value.GetSerial())
                        docBytes = append(docBytes, event)
                }</span>
                <span class="cov8" title="1">return payload, stat, subChan, subId, docBytes</span>
        }
        <span class="cov8" title="1">return payload, stat, nil, "", nil</span>
}

// DeleteChildDocument deletes a child document of the parent document d
// Returns a response (if an error occurred) and a status code
func (d *Document) DeleteChildDocument(docpath string, dbName string) ([]byte, int) <span class="cov8" title="1">{

        splitPath := strings.Split(docpath, "/")

        parentPath := splitPath[:len(splitPath)-2]

        parentColName := splitPath[len(splitPath)-2] //we need to Remove() on the collection

        victimName := splitPath[len(splitPath)-1]

        parentDoc, foundDoc := d.traverseDocuments(parentPath)

        if !foundDoc </span><span class="cov8" title="1">{
                errmsg, _ := json.Marshal("Document does not exist")
                return errmsg, http.StatusNotFound
        }</span>

        <span class="cov8" title="1">parentCol, foundCol := parentDoc.collections.Find(parentColName)

        if !foundCol </span><span class="cov8" title="1">{
                errmsg, _ := json.Marshal("Document does not exist")
                return errmsg, http.StatusNotFound
        }</span>
        <span class="cov8" title="1">removedDoc, removed := parentCol.Docs.Remove(victimName)

        if !removed </span><span class="cov8" title="1">{
                errmsg, _ := json.Marshal("Document does not exist")
                return errmsg, http.StatusNotFound
        }</span>
        //notifying all documents
        <span class="cov8" title="1">removedDoc.Notify(dbName+"/"+docpath, []byte("/"+docpath), "delete")
        colmsg, _ := json.Marshal("/" + docpath)

        parentCol.SubscriptionManager.Notify(victimName, "delete", colmsg)
        return nil, http.StatusNoContent</span>

}

// DeleteChildCollection deletes a collection within the document
// Returns a response (if an error occurred) and a status code
func (d *Document) DeleteChildCollection(colpath string) ([]byte, int) <span class="cov8" title="1">{
        newPath := colpath
        newPath = strings.TrimSuffix(newPath, "/")
        newSplitPath := strings.Split(newPath, "/")
        childColName := newSplitPath[len(newSplitPath)-1]
        parentDoc, found := d.traverseDocuments(newSplitPath[:len(newSplitPath)-1])
        if !found </span><span class="cov8" title="1">{ //the only way find fails is if the document is being deleted/can't be found, etc... so...
                errmsg, _ := json.Marshal("Owning document does not exist")
                return errmsg, http.StatusNotFound
        }</span>
        <span class="cov8" title="1">removedCol, removed := parentDoc.collections.Remove(childColName)

        if !removed </span><span class="cov8" title="1">{ //the only way remove fails is if the collection doesn't exist, so...
                errmsg, _ := json.Marshal("Collection does not exist")
                return errmsg, http.StatusNotFound
        }</span>
        <span class="cov8" title="1">slog.Debug("Notifiying subscribers that this collection is deleted")
        b, _ := json.Marshal("/" + colpath)
        removedCol.SubscriptionManager.NotifyAll(string(b))
        return nil, http.StatusNoContent</span>
}

// generatePutResponse creates a JSON response object for put requests
// Returns a JSON-encoded byte slice
func generatePutResponse(uri string, dbName string) ([]byte, string) <span class="cov8" title="1">{
        respJson := struct {
                Uri string `json:"uri"`
        }{
                Uri: "/v1/" + dbName + "/" + uri,
        }
        b, _ := json.Marshal(respJson)
        return b, respJson.Uri
}</span>

// traverseDocuments is helper method used to navigate from a parent document to it's descendant documents
// It returns the document at the end of the path, and a boolean indicating whether the document was found
func (d *Document) traverseDocuments(splitPath []string) (*Document, bool) <span class="cov8" title="1">{
        curDoc := d

        if len(splitPath) == 1 </span><span class="cov8" title="1">{
                return d, true
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; len(splitPath)-1; i += 2 </span><span class="cov8" title="1">{
                tmp, found := curDoc.traverseDocument(splitPath[i+1], splitPath[i+2])
                if !found </span><span class="cov8" title="1">{
                        return nil, false
                }</span>
                <span class="cov8" title="1">curDoc = tmp</span>
        }
        <span class="cov8" title="1">return curDoc, true</span>
}

// traverseDocument finds the document with name docName in collection colName, a collection belonging to the parent doc
// Returns the document and a boolean indicating whether the document was found
func (d *Document) traverseDocument(colName string, docName string) (*Document, bool) <span class="cov8" title="1">{
        var resDoc *Document
        var foundDoc bool
        nextCol, found := d.collections.Find(colName)
        if !found </span><span class="cov8" title="1">{
                return resDoc, found
        }</span>
        <span class="cov8" title="1">resDoc, foundDoc = nextCol.Docs.Find(docName)
        return resDoc, foundDoc</span>

}

// ApplyPatchDocument applies a JSON patch to the document at the specified path
// Returns a JSON-encoded response object and a status code
func (d *Document) ApplyPatchDocument(dbName string, docPath string, patch []byte, user string) ([]byte, int) <span class="cov8" title="1">{
        // Step 1: Split docPath into path segments and clean it
        splitPath := strings.Split(docPath, "/")

        // Step 2: Check if documentPath is for the root document
        splitPathToParent := splitPath[:len(splitPath)-2]
        parentColName := splitPath[len(splitPath)-2]
        parentDoc, found := d.traverseDocuments(splitPathToParent)

        if !found </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal("document at that path does not exist")
                return errmsg, http.StatusNotFound
        }</span>

        <span class="cov8" title="1">parentCol, found := parentDoc.collections.Find(parentColName)

        if !found </span><span class="cov8" title="1">{
                errmsg, _ := json.Marshal("owning collection does not exist")
                return errmsg, http.StatusNotFound
        }</span>
        <span class="cov8" title="1">docName := splitPath[len(splitPath)-1]
        // Use the same update function for documents within collections

        var nullDoc *Document
        var newDocPayload []byte
        chk := func(docName string, curDoc *Document, exists bool) (newDoc *Document, err error) </span><span class="cov8" title="1">{
                if !exists </span><span class="cov8" title="1">{ //can't update something that doesn't exist
                        return nullDoc, fmt.Errorf("document does not exist")
                }</span>
                <span class="cov8" title="1">newRaw, patchErr := curDoc.DoPatch(patch)
                if patchErr != nil </span><span class="cov0" title="0">{ //DO NOT UPDATE
                        return curDoc, patchErr
                }</span>
                <span class="cov8" title="1">err = d.validator.Validate(newRaw)
                if err != nil </span><span class="cov0" title="0">{
                        return curDoc, err
                }</span>
                <span class="cov8" title="1">curDoc.UpdateDoc(newRaw, user)

                newDocPayload = curDoc.GetSerial()
                //Notifying subscribers
                parentCol.SubscriptionManager.Notify(docName, "update", newDocPayload)
                curDoc.messager.NotifyDocs(dbName+"/"+docPath, "update", newDocPayload)
                return curDoc, nil</span>
        }
        <span class="cov8" title="1">updated, er := parentCol.Docs.Upsert(docName, chk)
        msg := "patch applied"
        if !updated </span><span class="cov8" title="1">{

                if er.Error() == "document does not exist" </span><span class="cov8" title="1">{
                        errmsg, _ := json.Marshal(er.Error())
                        return errmsg, http.StatusNotFound
                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(er.Error(), "bad patch operation") </span><span class="cov0" title="0">{
                        errmsg, _ := json.Marshal(er.Error())
                        return errmsg, http.StatusBadRequest
                }</span> else<span class="cov0" title="0"> {
                        msg = er.Error()
                }</span>
        }
        <span class="cov8" title="1">return generatePatchResponse(dbName, docName, !updated, msg), http.StatusOK</span>
}

// getRawBody gets ONLY THE BODY OF THE JSON DOCUMENT. DO NOT EVER GIVE THIS TO THE USER... FOR PATCHES ONLY!!!
// Returns a deep copy of the document's body
func (d *Document) getRawBody() []byte <span class="cov8" title="1">{
        deepCopy := make([]byte, len(d.Info.Doc))
        copy(deepCopy, d.Info.Doc)
        return deepCopy
}</span>

// DoPatch applies a JSON patch to the document
// Returns the patched document as a JSON-encoded byte slice
func (d *Document) DoPatch(patch []byte) (newRaw []byte, err error) <span class="cov8" title="1">{
        oldRaw := d.getRawBody()
        return d.patcher.DoPatch(oldRaw, patch)
}</span>

// UpdateDoc mutates the documents contents (DO NOT CALL THIS WITHOUT SYNCHRONIZATION)
func (d *Document) UpdateDoc(newRawDoc []byte, user string) <span class="cov8" title="1">{
        d.Info.Doc = newRawDoc
        d.Info.Meta.LastModifiedBy = user
        d.Info.Meta.LastModifiedAt = time.Now().UnixMilli()

}</span>

// generatePatchResponse generates a response for a patch operation
// Returns a JSON-encoded byte slice
func generatePatchResponse(dbName string, docPath string, patchFailed bool, msg string) []byte <span class="cov8" title="1">{

        uri := "/v1/" + dbName + "/" + docPath

        response := struct {
                Uri         string `json:"uri"`
                PatchFailed bool   `json:"patchFailed"`
                Message     string `json:"string"`
        }{
                Uri:         uri,
                PatchFailed: patchFailed,
                Message:     msg,
        }

        b, err := json.Marshal(response)
        if err != nil </span><span class="cov0" title="0">{
                slog.Warn("WARNING from docHelpers: JSON marshaling failed!")
        }</span>
        <span class="cov8" title="1">return b</span>
}

// Notify forwards the event notification to an internal subscription handler
func (d *Document) Notify(uri string, payload []byte, evType string) <span class="cov8" title="1">{
        d.messager.NotifyDocs(uri, evType, payload)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package document defines the structure and behaviors of documents within the database.
// It includes document management, collection indexing, validation, patching, and subscription handling.
package document

import (
        "github.com/RICE-COMP318-FALL24/owldb-p1group24/index_utils"
        "time"
)

// DocumentIndex defines the interface for managing collections within a document.
// It provides methods to find, upsert, and remove collections.
type DocumentIndex[Idx string, Col *Collection] interface {
        Find(key Idx) (foundVal Col, found bool)
        Upsert(key Idx, check index_utils.UpdateCheck[Idx, Col]) (updated bool, err error)
        Remove(key Idx) (removedVal Col, removed bool)
}

// Messager defines the interface for managing subscriptions within a document.
// It provides methods to notify documents and collections about updates
type Messager interface {
        AddDocSubscriber(uri string) (*chan []byte, string) //Adds a subscriber to the resource at doc

        NotifyDocs(uri string, evtype string, payload []byte)
}

// Validator defines an interface for validating documents.
type Validator interface {
        Validate(b []byte) error
}

// DocumentIndexFactory DocumentIndex holds collections
type DocumentIndexFactory[T DocumentIndex[string, *Collection]] func() T

// CollectionFactory is a function type that creates a new collection
type CollectionFactory func(string) *Collection

// SubscriptionManager manages subscriptions for changes to documents.
// It provides methods to add and remove subscribers and notify them of changes.
type SubscriptionManager interface {
        AddSubscriber() (ch *chan []byte, id string)        // Adds a new subscriber and returns a channel and subscriber ID.
        RemoveSubscriber(id string)                         // Removes a subscriber by its ID.
        Notify(evType string, payload []byte)               // Notifies subscribers of a document event (e.g., update or delete).
        GenerateEvent(evType string, payload []byte) []byte // Generates an event message for a given event type and payload.
}

// Patcher defines an interface for applying patches to documents.
type Patcher interface {
        DoPatch(oldDoc []byte, patches []byte) (newDoc []byte, err error) // DoPatch applies a patch to the old document and returns the new document.
}

// Document defines the structure of documents within the database.
type Document struct {
        Info docInfo `json:"info"` //the document's info; exposed as a JSON via API calls

        collectionFactory CollectionFactory //a factory function enabling the document to create new collections

        docCollectionFactory DocumentIndexFactory[DocumentIndex[string, *Collection]] //a factory enabling the user to inject their own data structures for holding other collection objects

        collections DocumentIndex[string, *Collection] //the collections belonging to a document

        sm SubscriptionManager //sm contains an interface SubscriptionManager, enabling the delegation of subscription management to any concrete implementation abiding by the method signatures

        smFactory SubscriptionManagerFactory //smFactory is a factory function that creates a new SubscriptionManager

        validator Validator // Validator for checking document contents.

        patcher Patcher // Patcher for applying modifications to the document.

        messager Messager //Messager for handling subscriptions
}

// metadata is a struct that holds information about the document
type metadata struct {
        CreatedBy      string `json:"createdBy"`      //the user who created the document
        CreatedAt      int64  `json:"createdAt"`      //the time the document was created
        LastModifiedBy string `json:"lastModifiedBy"` //the user who last modified the document
        LastModifiedAt int64  `json:"lastModifiedAt"` //the time the document was last modified
}

// docInfo contains the document's path, metadata, and the actual contents of the document.
type docInfo struct {
        Path string   `json:"path"` // The document's path.
        Meta metadata `json:"meta"` // Metadata associated with the document.
        Doc  []byte   `json:"doc"`  // The document's actual contents in byte form.
}

// newMeta creates a new metadata object with the current timestamp and the provided user.
// It sets both the creation and last modification timestamps to the current time.
func newMeta(user string) metadata <span class="cov8" title="1">{
        return metadata{
                CreatedBy:      user,
                CreatedAt:      time.Now().UnixMilli(),
                LastModifiedBy: user,
                LastModifiedAt: time.Now().UnixMilli(),
        }
}</span>

// New creates a new document object
// It initializes the document with the provided payload, user, path, and dependencies.
func New(payload []byte, user string, path string, dcf DocumentIndexFactory[DocumentIndex[string, *Collection]], ccf CollectionFactory, smfactory SubscriptionManagerFactory, v Validator, patcher Patcher, messager Messager) *Document <span class="cov8" title="1">{

        return &amp;Document{

                Info: docInfo{Doc: payload, Meta: newMeta(user), Path: "/" + path},

                docCollectionFactory: dcf,

                collections: dcf(),

                sm:                smfactory(),
                collectionFactory: ccf,
                smFactory:         smfactory,

                patcher:   patcher,
                validator: v,
                messager:  messager,
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// You MUST NOT modify this file.
//
// You MUST use JSONValue for all JSON values of unknown type (in other words
// the contents of documents).
//
// This package provides functionality to process and compare arbitrary JSON
// values.  The JSONValue type is a wrapper that holds unmarshaled JSON data.
// You should *only* access such JSON data using visitors with Accept, compare
// such JSON data using Equal, or validate such JSON data using Validate.
package jsondata

import (
        "encoding/json"
        "fmt"
        "reflect"
)

// A Validator is used to validate an unmarshaled JSON value.  The Validate
// method should return an error if the given JSON value is invalid and nil
// otherwise.
type Validator interface {
        Validate(any) error
}

// JSONValue is a wrapper around any type that is a valid JSON type.  Encoded
// JSON data should be unmarshaled directly into a variable of type JSONValue.
// JSONValues should then *only* be accessed using visitors with Accept,
// compared to other JSONValues using Equal, or validated by passing a
// validation function to the the Validate method.
//
// The zero value is the JSON null value.
//
// You can create JSONValues three ways:
//
// 1. Declare a variable of type JSONValue, which will represent the JSON null
// value.
//
// var j JSONValue
//
// 2. Unmarshal encoded JSON data directly into a variable of type JSONValue.
//
// var j JSONValue
// err := json.Unmarshal(data, &amp;j)
//
// 3. Use the NewJSONValue function to wrap a Go value of any valid JSON type.
// This function will return an error if the input value is not a valid JSON
// type.
//
// j, err := NewJSONValue(v)
//
// To convert a JSONValue (j) back to raw JSON data as a slide of bytes (b),
// use json.Marshal:
//
// b, err := json.Marshal(j)
type JSONValue struct {
        data any
}

func unwrap(v any) (any, error) <span class="cov8" title="1">{
        var err error

        // Handle nil first
        if v == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        // Handle JSONValue and primitive types with a type switch
        <span class="cov8" title="1">switch j := v.(type) </span>{
        case JSONValue:<span class="cov8" title="1">
                // Already a valid JSONValue, just return its data.
                return j.data, nil</span>
        case float64, bool, string:<span class="cov8" title="1">
                // These types are already valid JSON types.
                return v, nil</span>
        }

        // Handle collection types recursively using reflection.
        // Should only be map[string]any or []any.
        <span class="cov8" title="1">val := reflect.ValueOf(v)
        switch val.Kind() </span>{
        case reflect.Map:<span class="cov8" title="1">
                // Ensure that the map's keys are strings and unwrap its values.
                m := make(map[string]any)
                iter := val.MapRange()
                for iter.Next() </span><span class="cov8" title="1">{
                        key := iter.Key()
                        if key.Kind() != reflect.String </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid JSON key: %v", key)
                        }</span>
                        <span class="cov8" title="1">k := key.String()
                        value := iter.Value()
                        m[k], err = unwrap(value.Interface())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
                <span class="cov8" title="1">return m, nil</span>
        case reflect.Slice:<span class="cov8" title="1">
                // Unwrap the slice's elements.
                s := make([]any, val.Len())
                for i := 0; i &lt; val.Len(); i++ </span><span class="cov8" title="1">{
                        value := val.Index(i)
                        s[i], err = unwrap(value.Interface())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
                <span class="cov8" title="1">return s, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("invalid JSON value: %v", v)</span>
        }
}

// NewJSONValue returns a new JSONValue that wraps the given input value.
func NewJSONValue(v any) (JSONValue, error) <span class="cov8" title="1">{
        // Unwrap the input value and wrap it in a new JSONValue.
        data, err := unwrap(v)
        return JSONValue{data}, err
}</span>

// MarshalJSON returns the JSON encoding of the wrapped JSON value in j.
// Generally should only be used indirectly by json.Marshal when marshaling from
// a variable of type JSONValue.
func (j JSONValue) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(j.data)
}</span>

// UnmarshalJSON sets the wrapped JSON value in j to the result of unmarshaling
// the given input data. Returns an error if the input data is not valid JSON.
// Generally should only used indirectly by json.Unmarshal when unmarshaling
// into a variable of type JSONValue.
func (j *JSONValue) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        err := json.Unmarshal(data, &amp;j.data)
        return err
}</span>

// Equal returns true if other is deeply equal to j and false otherwise.
func (j JSONValue) Equal(other JSONValue) bool <span class="cov8" title="1">{
        return reflect.DeepEqual(j.data, other.data)
}</span>

// Validate applies the given validation function to the wrapped JSON value in
// j. Returns an error if the validation function returns an error.
func (j JSONValue) Validate(v Validator) error <span class="cov0" title="0">{
        return v.Validate(j.data)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// You MUST NOT modify this file.

// You MUST use JSONValue for all JSON values of unknown type (in other words
// the contents of documents).
//
// This package provides functionality to process and compare arbitrary JSON
// values.  The JSONValue type is a wrapper that holds unmarshaled JSON data.
// You should *only* access such JSON data using visitors with Accept, compare
// such JSON data using Equal, or validate such JSON data using Validate.
package jsondata

import (
        "fmt"
)

// A Visitor is used by Accept to process arbitrary values that only contain
// data of valid JSON types.  The Map and Slice methods may recursively call
// Accept on their constituent elements.
type Visitor[T any] interface {
        Map(map[string]JSONValue) (T, error)
        Slice([]JSONValue) (T, error)
        Bool(bool) (T, error)
        Float64(float64) (T, error)
        String(string) (T, error)
        Null() (T, error)
}

// Accept applies the given input visitor to the given input value by calling
// the appropriate visitor method on a copy of the input value given the input
// value's type. Returns an error if value is of a type that is not a valid JSON
// type or if the visitor method returns an error.
//
// As the visitor methods receive *copies* of the JSON values, any modifications
// will not affect the original JSON value.
//
// Note that this is a function so that the visitor and return value can be a
// generic type.  Go does not allow methods to have generic types unrelated to
// the receiver type.
func Accept[T any](value JSONValue, visitor Visitor[T]) (T, error) <span class="cov8" title="1">{
        wrap := func(v any) JSONValue </span><span class="cov8" title="1">{
                switch v := v.(type) </span>{
                case JSONValue:<span class="cov0" title="0">
                        return v</span>
                default:<span class="cov8" title="1">
                        return JSONValue{v}</span>
                }
        }

        <span class="cov8" title="1">switch val := value.data.(type) </span>{
        case map[string]any:<span class="cov8" title="1">
                m := make(map[string]JSONValue)
                for k, v := range val </span><span class="cov8" title="1">{
                        m[k] = wrap(v)
                }</span>
                <span class="cov8" title="1">return visitor.Map(m)</span>
        case []any:<span class="cov8" title="1">
                s := make([]JSONValue, len(val))
                for i, v := range val </span><span class="cov8" title="1">{
                        s[i] = wrap(v)
                }</span>
                <span class="cov8" title="1">return visitor.Slice(s)</span>
        case float64:<span class="cov0" title="0">
                return visitor.Float64(val)</span>
        case bool:<span class="cov8" title="1">
                return visitor.Bool(val)</span>
        case string:<span class="cov8" title="1">
                return visitor.String(val)</span>
        case nil:<span class="cov0" title="0">
                return visitor.Null()</span>
        default:<span class="cov0" title="0">
                var zero T
                return zero, fmt.Errorf("invalid JSON value: %s", value.data)</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Structured logger that allows you to set the log level
// and colorize the output.  You may choose to use this or
// not and you may modify it in any way.
//
// To use this, set up your logger as follows:
//
//        logOpts := &amp;logger.PrettyHandlerOptions{
//            Level:    slog.LevelDebug, // log level you want
//            Colorize: true,            // true or false
//        }
//
// handler := logger.NewPrettyHandler(os.Stdout, logOpts)
// logger := slog.New(handler)
// slog.SetDefault(logger)
package logger

import (
        "context"
        "fmt"
        "io"
        "log/slog"
        "runtime"
        "slices"
        "strings"
        "sync"
        "time"
        "unicode"
)

/*
 * Works on Linux, Windows 11, and MacOS 13
 *  (Does not work in Windows 10)
 */

// Escape codes for colorizing output.
const (
        Reset  = "\033[0m"
        Red    = "\033[31m"
        Green  = "\033[32m"
        Yellow = "\033[33m"
        Blue   = "\033[34m"
        Purple = "\033[35m"
        Cyan   = "\033[36m"
        Gray   = "\033[37m"
        White  = "\033[97m"
)

// PrettyHandlerOptions provides options for the PrettyHandler
type PrettyHandlerOptions struct {
        AddSource   bool
        Level       slog.Leveler
        ReplaceAttr func([]string, slog.Attr) slog.Attr
        Colorize    bool
}

// PrettyHandler is an slog.Handler that pretty-prints log records using color.
// Based upon:
//
//        https://github.com/golang/example/blob/master/slog-handler-guide/README.md
type PrettyHandler struct {
        pool *sync.Pool
        opts *PrettyHandlerOptions
        goas []groupOrAttrs
        mu   *sync.Mutex
        out  io.Writer
}

// groupOrAttrs holds either a group name or a list of slog.Attrs.
type groupOrAttrs struct {
        group string      // group name if non-empty
        attrs []slog.Attr // attrs if non-empty
}

// needsQuoting reports whether the string s needs quoting.
func needsQuoting(s string) bool <span class="cov0" title="0">{
        if len(s) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">for _, r := range s </span><span class="cov0" title="0">{
                if unicode.IsSpace(r) || strings.ContainsRune("!\"#$%&amp;'()*+,-/:;&lt;=&gt;?@[\\]^`{|}~", r) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// initPool initializes the pool of buffers for the PrettyHandler.
func (h *PrettyHandler) initPool() <span class="cov0" title="0">{
        h.pool = &amp;sync.Pool{
                New: func() any </span><span class="cov0" title="0">{
                        b := make([]byte, 0, 1024)
                        return &amp;b
                }</span>,
        }
}

// allocBuf returns a buffer from the pool.
func (h *PrettyHandler) allocBuf() *[]byte <span class="cov0" title="0">{
        if h.pool == nil </span><span class="cov0" title="0">{
                b := make([]byte, 0, 1024)
                return &amp;b
        }</span>

        <span class="cov0" title="0">return h.pool.Get().(*[]byte)</span>
}

// freeBuf returns a buffer to the pool.
func (h *PrettyHandler) freeBuf(b *[]byte) <span class="cov0" title="0">{
        if h.pool == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // To reduce peak allocation, return only smaller buffers to the pool.
        <span class="cov0" title="0">const maxBufferSize = 16 &lt;&lt; 10
        if cap(*b) &lt;= maxBufferSize </span><span class="cov0" title="0">{
                *b = (*b)[:0]
                h.pool.Put(b)
        }</span>
}

// qappendf appends a quoted string to the given buffer.
func qappendf(buf []byte, groups []string, val string) []byte <span class="cov0" title="0">{
        pstr := strings.Join(groups, ".")
        if len(groups) &gt; 0 </span><span class="cov0" title="0">{
                pstr = fmt.Sprintf("%s.", pstr)
        }</span>
        <span class="cov0" title="0">str := fmt.Sprintf("%s%s", pstr, val)
        if needsQuoting(str) </span><span class="cov0" title="0">{
                buf = fmt.Appendf(buf, "%q", str)
        }</span> else<span class="cov0" title="0"> {
                buf = fmt.Appendf(buf, "%s", str)
        }</span>
        <span class="cov0" title="0">return buf</span>
}

// appendAttr appends an attribute to the given buffer.
func (h *PrettyHandler) appendAttr(buf []byte, a slog.Attr, groups []string) []byte <span class="cov0" title="0">{
        // Resolve the Attr's value before doing anything else.
        a.Value = a.Value.Resolve()

        // Call ReplaceAttr, if provided.
        if rep := h.opts.ReplaceAttr; rep != nil &amp;&amp; a.Value.Kind() != slog.KindGroup </span><span class="cov0" title="0">{
                gs := slices.Clone(groups)
                a = rep(gs, a)
                a.Value = a.Value.Resolve()
        }</span>

        // Ignore empty Attrs.
        <span class="cov0" title="0">if a.Equal(slog.Attr{}) </span><span class="cov0" title="0">{
                return buf
        }</span>

        <span class="cov0" title="0">switch a.Value.Kind() </span>{
        case slog.KindString:<span class="cov0" title="0">
                // Prefix the attribute with a space
                buf = append(buf, " "...)

                // Output key=value
                buf = qappendf(buf, groups, a.Key)
                buf = append(buf, "="...)
                buf = qappendf(buf, []string{}, a.Value.String())</span>
        case slog.KindTime:<span class="cov0" title="0">
                // Prefix the attribute with a space
                buf = append(buf, " "...)

                // Output key=value
                buf = qappendf(buf, groups, a.Key)
                buf = append(buf, "="...)

                // Write times in a standard way, without the monotonic time.
                buf = fmt.Appendf(buf, "%s", a.Value.Time().Format(time.RFC3339Nano))</span>
        case slog.KindGroup:<span class="cov0" title="0">
                attrs := a.Value.Group()
                // Ignore empty groups.
                if len(attrs) == 0 </span><span class="cov0" title="0">{
                        return buf
                }</span>
                // If the key is non-empty, add group to groups.
                <span class="cov0" title="0">if a.Key != "" </span><span class="cov0" title="0">{
                        groups = append(groups, a.Key)
                }</span>

                // Output group's attributes.
                <span class="cov0" title="0">for _, ga := range attrs </span><span class="cov0" title="0">{
                        buf = h.appendAttr(buf, ga, groups)
                }</span>
        default:<span class="cov0" title="0">
                // Prefix the attribute with a space
                buf = append(buf, " "...)

                // Output key=value
                buf = qappendf(buf, groups, a.Key)
                buf = append(buf, "="...)
                buf = fmt.Appendf(buf, "%s", a.Value)</span>
        }

        <span class="cov0" title="0">return buf</span>
}

// Enabled returns true if the logging level is enabled.
func (h *PrettyHandler) Enabled(ctx context.Context, level slog.Level) bool <span class="cov0" title="0">{
        return level &gt;= h.opts.Level.Level()
}</span>

// Handle writes the record to the output.
func (h *PrettyHandler) Handle(ctx context.Context, r slog.Record) error <span class="cov0" title="0">{
        // Allocate a buffer for the record from the pool.
        bufp := h.allocBuf()
        buf := *bufp
        defer func() </span><span class="cov0" title="0">{
                *bufp = buf
                h.freeBuf(bufp)
        }</span>()

        <span class="cov0" title="0">groups := make([]string, 0)

        if h.opts.Colorize </span><span class="cov0" title="0">{
                // Set the color based on the level of the record.
                if r.Level == slog.LevelError </span><span class="cov0" title="0">{
                        buf = append(buf, Red...)
                }</span> else<span class="cov0" title="0"> if r.Level == slog.LevelWarn </span><span class="cov0" title="0">{
                        buf = append(buf, Yellow...)
                }</span> else<span class="cov0" title="0"> if r.Level == slog.LevelDebug </span><span class="cov0" title="0">{
                        buf = append(buf, Cyan...)
                }</span> else<span class="cov0" title="0"> {
                        // Default to white.
                        buf = append(buf, White...)
                }</span>
        }

        <span class="cov0" title="0">var a slog.Attr

        // Time
        if !r.Time.IsZero() </span><span class="cov0" title="0">{
                if rep := h.opts.ReplaceAttr; rep != nil </span><span class="cov0" title="0">{
                        // Call ReplaceAttr, if provided.
                        gs := slices.Clone(groups)
                        a = rep(gs, slog.Time(slog.TimeKey, r.Time))
                        a.Value = a.Value.Resolve()
                        if !a.Equal(slog.Attr{}) </span><span class="cov0" title="0">{
                                if a.Key == slog.TimeKey </span><span class="cov0" title="0">{
                                        buf = qappendf(buf, groups, a.Value.String())
                                        buf = append(buf, " "...)
                                }</span> else<span class="cov0" title="0"> {
                                        buf = h.appendAttr(buf, a, groups)
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        buf = fmt.Appendf(buf, "%s ", r.Time.Format("2006/01/02 15:04:05"))
                }</span>
        }

        // Level
        <span class="cov0" title="0">if rep := h.opts.ReplaceAttr; rep != nil </span><span class="cov0" title="0">{
                // Call ReplaceAttr, if provided.
                gs := slices.Clone(groups)
                a = rep(gs, slog.Any(slog.LevelKey, r.Level))
                a.Value = a.Value.Resolve()
                if !a.Equal(slog.Attr{}) </span><span class="cov0" title="0">{
                        if a.Key == slog.LevelKey </span><span class="cov0" title="0">{
                                buf = qappendf(buf, groups, a.Value.String())
                                buf = append(buf, " "...)
                        }</span> else<span class="cov0" title="0"> {
                                buf = h.appendAttr(buf, a, groups)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                buf = fmt.Appendf(buf, "%s ", r.Level)
        }</span>

        // Message
        <span class="cov0" title="0">if rep := h.opts.ReplaceAttr; rep != nil </span><span class="cov0" title="0">{
                // Call ReplaceAttr, if provided.
                gs := slices.Clone(groups)
                a = rep(gs, slog.Any(slog.MessageKey, r.Message))
                a.Value = a.Value.Resolve()
                if !a.Equal(slog.Attr{}) </span><span class="cov0" title="0">{
                        if a.Key == slog.MessageKey </span><span class="cov0" title="0">{
                                buf = fmt.Appendf(buf, "%s", a.Value.String())
                        }</span> else<span class="cov0" title="0"> {
                                buf = h.appendAttr(buf, a, groups)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                buf = fmt.Appendf(buf, "%s", r.Message)
        }</span>

        // Source
        <span class="cov0" title="0">if h.opts.AddSource &amp;&amp; r.PC != 0 </span><span class="cov0" title="0">{
                fs := runtime.CallersFrames([]uintptr{r.PC})
                f, _ := fs.Next()
                buf = h.appendAttr(buf, slog.String(slog.SourceKey, fmt.Sprintf("%s:%d", f.File, f.Line)), groups)
        }</span>

        // Handle state from WithGroup and WithAttrs.

        <span class="cov0" title="0">goas := h.goas
        if r.NumAttrs() == 0 </span><span class="cov0" title="0">{
                // If the record has no Attrs, remove groups at the end of the list; they are empty.
                for len(goas) &gt; 0 &amp;&amp; goas[len(goas)-1].group != "" </span><span class="cov0" title="0">{
                        goas = goas[:len(goas)-1]
                }</span>
        }
        <span class="cov0" title="0">for _, goa := range goas </span><span class="cov0" title="0">{
                if goa.group != "" </span><span class="cov0" title="0">{
                        groups = append(groups, goa.group)
                }</span> else<span class="cov0" title="0"> {
                        for _, a := range goa.attrs </span><span class="cov0" title="0">{
                                buf = h.appendAttr(buf, a, groups)
                        }</span>
                }
        }
        <span class="cov0" title="0">r.Attrs(func(a slog.Attr) bool </span><span class="cov0" title="0">{
                buf = h.appendAttr(buf, a, groups)
                return true
        }</span>)

        // Newline and reset color.
        <span class="cov0" title="0">if h.opts.Colorize </span><span class="cov0" title="0">{
                buf = append(buf, Reset...)
        }</span>
        <span class="cov0" title="0">buf = append(buf, "\n"...)

        // Write to the output.
        h.mu.Lock()
        defer h.mu.Unlock()
        _, err := h.out.Write(buf)
        return err</span>
}

// withGroupOrAttrs returns a new PrettyHandler with the given group or attributes added.
func (h *PrettyHandler) withGroupOrAttrs(goa groupOrAttrs) *PrettyHandler <span class="cov0" title="0">{
        h2 := *h
        h2.goas = make([]groupOrAttrs, len(h.goas)+1)
        copy(h2.goas, h.goas)
        h2.goas[len(h2.goas)-1] = goa
        return &amp;h2
}</span>

// WithGroup returns a new PrettyHandler with the group name added.
func (h *PrettyHandler) WithGroup(name string) slog.Handler <span class="cov0" title="0">{
        if name == "" </span><span class="cov0" title="0">{
                return h
        }</span>
        <span class="cov0" title="0">return h.withGroupOrAttrs(groupOrAttrs{group: name})</span>
}

// WithAttrs returns a new PrettyHandler with the attributes added.
func (h *PrettyHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov0" title="0">{
        if len(attrs) == 0 </span><span class="cov0" title="0">{
                return h
        }</span>
        <span class="cov0" title="0">return h.withGroupOrAttrs(groupOrAttrs{attrs: attrs})</span>
}

// NewPrettyHandler creates a new PrettyHandler with the given options.
func NewPrettyHandler(w io.Writer, opts *PrettyHandlerOptions) *PrettyHandler <span class="cov0" title="0">{
        if opts == nil </span><span class="cov0" title="0">{
                opts = &amp;PrettyHandlerOptions{
                        Level: slog.LevelInfo,
                }
        }</span>
        <span class="cov0" title="0">h := &amp;PrettyHandler{nil, opts, nil, &amp;sync.Mutex{}, w}
        h.initPool()

        return h</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Package main initializes and runs the server for the OwlDB project.
// It sets up the necessary dependencies, including the document schema, database,
// and authentication services.
package main

import (
        "flag"
        "fmt"
        "github.com/RICE-COMP318-FALL24/owldb-p1group24/auth"
        "github.com/RICE-COMP318-FALL24/owldb-p1group24/concurrentSkipList"
        "github.com/RICE-COMP318-FALL24/owldb-p1group24/logger"
        "github.com/RICE-COMP318-FALL24/owldb-p1group24/patcher"
        "github.com/RICE-COMP318-FALL24/owldb-p1group24/resourceCreatorService"
        "github.com/RICE-COMP318-FALL24/owldb-p1group24/resourceDeleterService"
        "github.com/RICE-COMP318-FALL24/owldb-p1group24/resourceGetterService"
        "github.com/RICE-COMP318-FALL24/owldb-p1group24/resourcePatcherService"
        "github.com/RICE-COMP318-FALL24/owldb-p1group24/subscriptionManager"
        "github.com/RICE-COMP318-FALL24/owldb-p1group24/validation"
        "log/slog"
        "net/http"
        "os"
        "os/signal"
        "syscall"

        "github.com/RICE-COMP318-FALL24/owldb-p1group24/db"

        "github.com/RICE-COMP318-FALL24/owldb-p1group24/document"
        "github.com/RICE-COMP318-FALL24/owldb-p1group24/server"
)

func main() <span class="cov0" title="0">{
        var srv http.Server
        var port int
        var schema string
        var tokens string
        var err error

        // Parse command-line flags for port, schema, and tokens
        flag.IntVar(&amp;port, "p", 3318, "port number")

        // might need to change "document.json" to "" to make sure when passing in schema exist

        flag.StringVar(&amp;schema, "s", "", "document schema")

        flag.StringVar(&amp;tokens, "t", "", "tokens")
        flag.Parse()

        // Initialize logging options
        logOpts := &amp;logger.PrettyHandlerOptions{
                Level:    slog.LevelDebug,
                Colorize: true,
        }
        handler1 := logger.NewPrettyHandler(os.Stdout, logOpts)
        logger1 := slog.New(handler1)
        slog.SetDefault(logger1)

        //Check if schema file is provided
        if schema == "" </span><span class="cov0" title="0">{
                fmt.Printf("Error: Schema file not specified. Use -s &lt;schema filename&gt;\n")
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">validator, err := validation.New(schema)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error: Bad schema file\n")
                os.Exit(1)
        }</span>
        // Dependency injection and factory initialization
        <span class="cov0" title="0">var docColFactory document.DocumentIndexFactory[document.DocumentIndex[string, *document.Collection]]

        var dbFactory resourceCreatorService.DBFactory[*db.Database[string, *document.Document]]

        var docFactory db.DocFactory[*document.Document]
        var newerColFactory document.CollectionFactory
        newerColFactory = func(colName string) *document.Collection </span><span class="cov0" title="0">{
                return &amp;document.Collection{
                        Name:                colName,
                        Docs:                concurrentSkipList.NewSL[string, *document.Document](string(rune(0)), string(rune(127))),
                        SubscriptionManager: subscriptionManager.NewColSubManager(concurrentSkipList.NewSL[string, subscriptionManager.Colsubscriber](string(rune(0)), string(rune(127)))),
                }
        }</span>

        <span class="cov0" title="0">var smFactory document.SubscriptionManagerFactory = func() document.SubscriptionManager </span><span class="cov0" title="0">{
                subs := concurrentSkipList.NewSL[string, *chan []byte](string(rune(0)), string(rune(127)))
                return subscriptionManager.New(subs)
        }</span>

        <span class="cov0" title="0">var idtosubfactory subscriptionManager.IdToSubFactory = func() subscriptionManager.IdToSub[string, *chan []byte] </span><span class="cov0" title="0">{
                return concurrentSkipList.NewSL[string, *chan []byte](string(rune(0)), string(rune(127)))
        }</span>

        <span class="cov0" title="0">docSubs := concurrentSkipList.NewSL[string, *subscriptionManager.SubscriptionManager](string(rune(0)), string(rune(127)))
        messager := subscriptionManager.NewMessager(idtosubfactory, docSubs)
        docFactory = func(payload []byte, user string, path string) *document.Document </span><span class="cov0" title="0">{

                newDoc := document.New(payload, user, path, docColFactory, newerColFactory, smFactory, validator, patcher.Patcher{}, messager)
                return newDoc
        }</span>

        <span class="cov0" title="0">docColFactory = func() document.DocumentIndex[string, *document.Collection] </span><span class="cov0" title="0">{
                newCollections := concurrentSkipList.NewSL[string, *document.Collection](string(rune(0)), string(rune(127)))
                return newCollections
        }</span>

        <span class="cov0" title="0">dbFactory = func(name string) *db.Database[string, *document.Document] </span><span class="cov0" title="0">{
                newDBIndices := concurrentSkipList.NewSL[string, *document.Document](string(rune(0)), string(rune(127)))
                sm := subscriptionManager.NewColSubManager(concurrentSkipList.NewSL[string, subscriptionManager.Colsubscriber](string(rune(0)), string(rune(127))))
                return db.New[string, *document.Document](name, docFactory, newDBIndices, sm, validator)

        }</span>
        //FOR CRUD OPERATIONS
        // Initialize database and resource services
        <span class="cov0" title="0">dbs := concurrentSkipList.NewSL[string, *db.Database[string, *document.Document]](string(rune(0)), string(rune(127)))
        var rcsDB resourceCreatorService.DatabaseIndex[string, *db.Database[string, *document.Document]] = dbs
        var rgsDB resourceGetterService.DatabaseIndex[string, *db.Database[string, *document.Document]] = dbs
        var rdsDB resourceDeleterService.DatabaseIndex[string, *db.Database[string, *document.Document]] = dbs
        var rpsDB resourcePatcherService.DatabaseIndex[string, *db.Database[string, *document.Document]] = dbs
        rcs := resourceCreatorService.New(rcsDB, dbFactory, validator)
        rgs := resourceGetterService.New(rgsDB)
        rds := resourceDeleterService.New(rdsDB)
        rps := resourcePatcherService.New(rpsDB)

        // Initialize authentication services

        var tokenMap auth.TokenIndex[string, auth.Session] = concurrentSkipList.NewSL[string, auth.Session](string(rune(0)), string(rune(127)))

        authService := auth.New(tokenMap, tokens)

        // Initialize the server handler
        handler := server.New(rds, rgs, rcs, authService, rps)
        srv.Handler = handler
        srv.Addr = fmt.Sprintf(":%d", port)

        // The following code should go last and remain unchanged.
        // Note that you must actually initialize 'server' and 'port'
        // before this.  Note that the server is started below by
        // calling ListenAndServe.  You must not start the server
        // before this.

        // signal.Notify requires the channel to be buffered
        ctrlc := make(chan os.Signal, 1)
        signal.Notify(ctrlc, os.Interrupt, syscall.SIGTERM)
        go func() </span><span class="cov0" title="0">{
                // Wait for Ctrl-C signal
                &lt;-ctrlc
                srv.Close()
        }</span>()

        // Start server
        <span class="cov0" title="0">slog.Info("Listening", "port", port)
        err = srv.ListenAndServe()
        if err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                slog.Error("Server closed", "error", err)
        }</span> else<span class="cov0" title="0"> {
                slog.Info("Server closed", "error", err)
        }</span>

        <span class="cov0" title="0">slog.Info("Server closed")</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package mocks

import (
        "cmp"
        "context"
        "encoding/json"
        "github.com/RICE-COMP318-FALL24/owldb-p1group24/index_utils"
        "sync"
)

type dummyPayload struct {
        Name     string
        Message  string
        Likes    int
        Dislikes int
}

func MockPayload() []byte <span class="cov8" title="1">{
        messageStruct := dummyPayload{
                Name:     "John",
                Message:  "Hello",
                Likes:    30,
                Dislikes: -5000,
        }
        b, _ := json.Marshal(messageStruct)
        return b
}</span>

type mockMeta struct {
}

type MockSL[K cmp.Ordered, V any] struct {
        sl map[K]V
        mu sync.Mutex
}

func NewMockSL[K cmp.Ordered, V any]() *MockSL[K, V] <span class="cov8" title="1">{
        return &amp;MockSL[K, V]{sl: make(map[K]V)}
}</span>

func (m *MockSL[K, V]) Find(key K) (foundValue V, found bool) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        v, ok := m.sl[key]
        if !ok </span><span class="cov8" title="1">{
                return v, false
        }</span>
        <span class="cov8" title="1">return v, true</span>
}

func (m *MockSL[K, V]) Remove(key K) (foundValue V, found bool) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        v, ok := m.sl[key]
        if !ok </span><span class="cov8" title="1">{
                return v, false
        }</span>
        <span class="cov8" title="1">delete(m.sl, key)
        return v, true</span>
}

func (m *MockSL[K, V]) Query(ctx context.Context, low K, hi K) (result []index_utils.Pair[K, V], err error) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        res := make([]index_utils.Pair[K, V], 0)
        for k, v := range m.sl </span><span class="cov8" title="1">{
                if low &lt;= k &amp;&amp; k &lt;= hi </span><span class="cov8" title="1">{
                        p := index_utils.Pair[K, V]{Key: k, Value: v}
                        res = append(res, p)
                }</span>
        }
        <span class="cov8" title="1">return res, nil</span>
}

func (m *MockSL[K, V]) Upsert(key K, check index_utils.UpdateCheck[K, V]) (bool, error) <span class="cov8" title="1">{
        curVal, exists := m.sl[key]
        m.mu.Lock()
        defer m.mu.Unlock()
        newVal, err := check(key, curVal, exists)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">m.sl[key] = newVal
        return true, nil</span>

}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Package patcher provides functionality for applying patches to JSON data using a visitor pattern.
// It supports operations such as adding and removing elements from JSON objects and arrays.
package patcher

import (
        "errors"
        "fmt"
        "github.com/RICE-COMP318-FALL24/owldb-p1group24/jsondata"
        "log/slog"
        "strings"
)

// PatchVisitor applies a single patch operation to a JSONValue during traversal.
type PatchVisitor struct {
        Patch         PatchOperation
        CurrentPath   string
        Failed        bool
        FailureReason string
        pathFound     bool
}

// NewPatchVisitor creates a new PatchVisitor for a single patch operation.
func NewPatchVisitor(patch PatchOperation) *PatchVisitor <span class="cov8" title="1">{
        return &amp;PatchVisitor{
                Patch:         patch,
                CurrentPath:   "",
                Failed:        false,
                FailureReason: "",
                pathFound:     false,
        }
}</span>

// Map applies the ObjectAdd operation.
// Map processes a JSON object (map) by iterating through its key-value pairs.
// It applies ObjectAdd operations if specified in the patches and then recursively traverses the map.
// Returns the updated JSONValue and an error if the operation fails.

func (pv *PatchVisitor) Map(m map[string]jsondata.JSONValue) (jsondata.JSONValue, error) <span class="cov8" title="1">{
        newMap := make(map[string]jsondata.JSONValue)

        // Copy existing key-value pairs to the new map
        for existingKey, existingValue := range m </span><span class="cov8" title="1">{
                newMap[existingKey] = existingValue
        }</span>

        //if it's last path we have for patch, check whether it's arrayadd or arrayremove, if so, return error
        <span class="cov8" title="1">if (pv.Patch.Op == "ArrayAdd" || pv.Patch.Op == "ArrayRemove") &amp;&amp;
                pv.CurrentPath == normalizeJSONPointer(pv.Patch.Path) </span><span class="cov8" title="1">{

                // Set failure flags and reason
                pv.Failed = true
                pv.FailureReason = fmt.Sprintf("error applying patches: path '%s' ends in an object, expected array", pv.Patch.Path)

                // Log the error for debugging
                slog.Error("Invalid patch operation on object", "operation", pv.Patch.Op, "path", pv.Patch.Path)

                // Return an empty JSONValue and the error
                return jsondata.JSONValue{}, errors.New(pv.FailureReason)
        }</span>
        <span class="cov8" title="1">if pv.Patch.Op == "ObjectAdd" &amp;&amp; pv.CurrentPath == parentJSONPointer(pv.Patch.Path) </span><span class="cov8" title="1">{
                patchSegments, err := splitJSONPointer(pv.Patch.Path)
                if err != nil </span><span class="cov0" title="0">{
                        pv.Failed = true
                        pv.FailureReason = fmt.Sprintf("Invalid JSON Pointer '%s': %v", pv.Patch.Path, err)
                        return jsondata.JSONValue{}, errors.New(pv.FailureReason)
                }</span>

                <span class="cov8" title="1">if len(patchSegments) == 0 </span><span class="cov8" title="1">{
                        pv.Failed = true
                        pv.FailureReason = fmt.Sprintf("Invalid path '%s': no key specified", pv.Patch.Path)
                        return jsondata.JSONValue{}, errors.New(pv.FailureReason)
                }</span>

                <span class="cov8" title="1">key := patchSegments[len(patchSegments)-1]

                if _, exists := newMap[key]; exists </span><span class="cov8" title="1">{
                        // Key exists, do nothing
                        slog.Debug("ObjectAdd operation skipped: key already exists", "key", key, "path", pv.CurrentPath)
                        return jsondata.NewJSONValue(m)
                }</span>

                // Add the key-value pair
                <span class="cov8" title="1">pv.pathFound = true
                newMap[key] = pv.Patch.Value
                slog.Debug("ObjectAdd operation applied", "key", key, "path", pv.CurrentPath)</span>
        }

        // Traverse the map
        <span class="cov8" title="1">for k, v := range newMap </span><span class="cov8" title="1">{
                previousPath := pv.CurrentPath
                pv.CurrentPath = pv.CurrentPath + "/" + escapeJSONPointer(k)

                //check if pathfound == true, if so, it means already did object add. Can return
                // Before recursive call
                if pv.pathFound </span><span class="cov8" title="1">{
                        // The operation has been applied, we can return early
                        return jsondata.NewJSONValue(newMap)
                }</span>

                // Recursively accept
                <span class="cov8" title="1">newValue, err := jsondata.Accept[jsondata.JSONValue](v, pv)
                if err != nil </span><span class="cov8" title="1">{
                        return jsondata.JSONValue{}, err
                }</span>
                <span class="cov8" title="1">newMap[k] = newValue

                // Restore the previous path
                pv.CurrentPath = previousPath</span>
        }

        <span class="cov8" title="1">return jsondata.NewJSONValue(newMap)</span>
}

// Slice applies ArrayAdd and ArrayRemove operations.

// Slice processes a JSON array by iterating through its elements.
// Returns the updated JSONValue and an error if the operation fails.

func (pv *PatchVisitor) Slice(s []jsondata.JSONValue) (jsondata.JSONValue, error) <span class="cov8" title="1">{
        slog.Info("PATCHING 3")
        newSlice := make([]jsondata.JSONValue, len(s))
        copy(newSlice, s)

        if (pv.Patch.Op == "ArrayAdd" || pv.Patch.Op == "ArrayRemove") &amp;&amp;
                normalizeJSONPointer(pv.CurrentPath) == normalizeJSONPointer(pv.Patch.Path) </span><span class="cov8" title="1">{
                if pv.Patch.Op == "ArrayAdd" </span><span class="cov8" title="1">{
                        // Add the value if it's not already in the array
                        exists := false
                        pv.pathFound = true
                        for _, item := range newSlice </span><span class="cov8" title="1">{
                                if item.Equal(pv.Patch.Value) </span><span class="cov8" title="1">{
                                        exists = true
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                                newSlice = append(newSlice, pv.Patch.Value)
                        }</span>
                } else<span class="cov8" title="1"> if pv.Patch.Op == "ArrayRemove" </span><span class="cov8" title="1">{
                        // Remove the value if it's in the array
                        found := false
                        pv.pathFound = true
                        tempSlice := []jsondata.JSONValue{}
                        for _, item := range newSlice </span><span class="cov8" title="1">{
                                if item.Equal(pv.Patch.Value) </span><span class="cov8" title="1">{
                                        found = true
                                }</span> else<span class="cov8" title="1"> {
                                        tempSlice = append(tempSlice, item)
                                }</span>
                        }
                        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                                pv.Failed = true
                                pv.FailureReason = fmt.Sprintf("Value not found in array at path '%s'", pv.CurrentPath)
                                return jsondata.JSONValue{}, errors.New(pv.FailureReason)
                        }</span>
                        <span class="cov8" title="1">newSlice = tempSlice</span>
                }
        }

        // Traverse the array
        <span class="cov8" title="1">for i, v := range newSlice </span><span class="cov8" title="1">{
                previousPath := pv.CurrentPath
                pv.CurrentPath = fmt.Sprintf("%s/%d", pv.CurrentPath, i)

                // Recursively accept
                newValue, err := jsondata.Accept[jsondata.JSONValue](v, pv)
                if err != nil </span><span class="cov0" title="0">{
                        return jsondata.JSONValue{}, err
                }</span>
                <span class="cov8" title="1">newSlice[i] = newValue

                // Restore the previous path
                pv.CurrentPath = previousPath</span>
        }
        <span class="cov8" title="1">slog.Info(fmt.Sprintf("newslice is %+v", newSlice))

        return jsondata.NewJSONValue(newSlice)</span>
}

// Bool returns an error if a patch operation targets a boolean value at the current path
func (pv *PatchVisitor) Bool(b bool) (jsondata.JSONValue, error) <span class="cov8" title="1">{
        if normalizeJSONPointer(pv.CurrentPath) == normalizeJSONPointer(pv.Patch.Path) </span><span class="cov0" title="0">{
                // Patch operation targets a boolean, which is invalid
                pv.Failed = true
                pv.FailureReason = fmt.Sprintf("Cannot apply operation '%s' on a boolean at path '%s'", pv.Patch.Op, pv.Patch.Path)
                return jsondata.JSONValue{}, errors.New(pv.FailureReason)
        }</span>
        // Continue traversal without error
        <span class="cov8" title="1">return jsondata.NewJSONValue(b)</span>
}

// Float64 returns an error if a patch operation targets a float64 value at the current path
func (pv *PatchVisitor) Float64(f float64) (jsondata.JSONValue, error) <span class="cov0" title="0">{
        if normalizeJSONPointer(pv.CurrentPath) == normalizeJSONPointer(pv.Patch.Path) </span><span class="cov0" title="0">{
                // Patch operation targets a float64, which is invalid
                pv.Failed = true
                pv.FailureReason = fmt.Sprintf("Cannot apply operation '%s' on a number at path '%s'", pv.Patch.Op, pv.Patch.Path)
                return jsondata.JSONValue{}, errors.New(pv.FailureReason)
        }</span>
        // Continue traversal without error
        <span class="cov0" title="0">return jsondata.NewJSONValue(f)</span>
}

// String returns an error if a patch operation targets a string value at the current path
func (pv *PatchVisitor) String(s string) (jsondata.JSONValue, error) <span class="cov8" title="1">{
        if normalizeJSONPointer(pv.CurrentPath) == normalizeJSONPointer(pv.Patch.Path) </span><span class="cov8" title="1">{
                // Patch operation targets a string, which is invalid
                pv.Failed = true
                pv.FailureReason = fmt.Sprintf("error applying patches:  find string along path")
                return jsondata.JSONValue{}, errors.New(pv.FailureReason)
        }</span>
        // Continue traversal without error
        <span class="cov8" title="1">return jsondata.NewJSONValue(s)</span>
}

// Null returns an error if a patch operation targets a null value at the current path
func (pv *PatchVisitor) Null() (jsondata.JSONValue, error) <span class="cov0" title="0">{
        if normalizeJSONPointer(pv.CurrentPath) == normalizeJSONPointer(pv.Patch.Path) </span><span class="cov0" title="0">{
                // Patch operation targets null, which is invalid
                pv.Failed = true
                pv.FailureReason = fmt.Sprintf("error applying patches:  find null along path")
                return jsondata.JSONValue{}, errors.New(pv.FailureReason)
        }</span>
        // Continue traversal without error
        <span class="cov0" title="0">return jsondata.NewJSONValue(nil)</span>
}

// Helper functions

// parentJSONPointer returns the parent path of a given JSON pointer.
func parentJSONPointer(ptr string) string <span class="cov8" title="1">{
        if ptr == "" || ptr == "/" </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">idx := strings.LastIndex(ptr, "/")
        if idx &lt;= 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return ptr[:idx]</span>
}

// normalizeJSONPointer normalizes a JSON pointer to ensure it follows the correct format.
func normalizeJSONPointer(ptr string) string <span class="cov8" title="1">{
        if ptr == "" </span><span class="cov8" title="1">{
                return "/"
        }</span>
        <span class="cov8" title="1">return ptr</span>
}

// splitJSONPointer splits a JSON pointer into its individual segments.
func splitJSONPointer(ptr string) ([]string, error) <span class="cov8" title="1">{
        if ptr == "" </span><span class="cov8" title="1">{
                return []string{}, nil
        }</span>
        <span class="cov8" title="1">if ptr[0] != '/' </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid JSON Pointer: %s", ptr)
        }</span>
        <span class="cov8" title="1">parts := strings.Split(ptr[1:], "/")
        for i, part := range parts </span><span class="cov8" title="1">{
                parts[i] = strings.ReplaceAll(strings.ReplaceAll(part, "~1", "/"), "~0", "~")
        }</span>
        <span class="cov8" title="1">return parts, nil</span>
}

// escapeJSONPointer escapes a string to be safely used as a JSON pointer.
func escapeJSONPointer(s string) string <span class="cov8" title="1">{
        s = strings.ReplaceAll(s, "~", "~0")
        s = strings.ReplaceAll(s, "/", "~1")
        return s
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// Package patcher provides functionality for applying a sequence of patches to JSON documents.
// It defines structures and methods for handling patch operations and applying them to JSON data.
package patcher

import (
        "encoding/json"
        "errors"
        "fmt"
        "github.com/RICE-COMP318-FALL24/owldb-p1group24/jsondata"
        "log/slog"
)

// PatchOperation defines a single patch operation to be applied to a JSON document.
// It includes the operation type (Op), the path in the document (Path), and the value to be applied (Value).
type PatchOperation struct {
        Op    string             `json:"op"`    // The operation type (e.g., "add", "remove").
        Path  string             `json:"path"`  // The JSON Pointer path specifying where the operation should be applied.
        Value jsondata.JSONValue `json:"value"` // The value to add, remove, or modify at the specified path.
}

// Patcher is responsible for applying a sequence of patches to a JSON document.
type Patcher struct {
}

// DoPatch takes the raw bytes from both the original document, a json-encoded list of patch objects, and applies them sequentially
// returns whether the patch was successful or not
func (p Patcher) DoPatch(oldRawDoc []byte, rawPatches []byte) (newDoc []byte, err error) <span class="cov8" title="1">{

        var jsonValue jsondata.JSONValue
        slog.Info("PATCHING")

        err = json.Unmarshal(oldRawDoc, &amp;jsonValue)

        if err != nil </span><span class="cov8" title="1">{ //this should NOT fail
                slog.Warn("WARNING: A BAD DOCUMENT PAYLOAD IS IN THE DATABASE")
                return oldRawDoc, fmt.Errorf("malformed raw document payload")
        }</span>

        <span class="cov8" title="1">var patches []PatchOperation
        if err := json.Unmarshal(rawPatches, &amp;patches); err != nil </span><span class="cov8" title="1">{
                slog.Debug("Invalid PATCH")
                return nil, err
        }</span>
        <span class="cov8" title="1">patchErr := validatePatches(patches)
        if patchErr != nil </span><span class="cov8" title="1">{
                return oldRawDoc, patchErr
        }</span>
        <span class="cov8" title="1">for _, patchOp := range patches </span><span class="cov8" title="1">{
                slog.Info("PATCHING 2")
                // Create a new PatchVisitor for the current patch operation
                patchVisitor := NewPatchVisitor(patchOp)

                // Apply the patch to the current jsonValue

                //I dont think you need to type cast here since the visitor is already a visitor.... I think
                patchedValue, err := jsondata.Accept[jsondata.JSONValue](jsonValue, patchVisitor)
                if err != nil || patchVisitor.Failed </span><span class="cov8" title="1">{
                        if patchVisitor.FailureReason != "" </span><span class="cov8" title="1">{
                                return oldRawDoc, err
                        }</span>
                        <span class="cov0" title="0">return oldRawDoc, err</span>
                }
                <span class="cov8" title="1">if !patchVisitor.pathFound </span><span class="cov8" title="1">{
                        msg := fmt.Sprintf("Error Applying patches:  Path '%s' does not exist in the document", patchOp.Path) // invalid patch
                        slog.Error(msg)
                        return nil, errors.New(msg)
                }</span>

                // Update jsonValue for the next patch operation
                <span class="cov0" title="0">jsonValue = patchedValue</span>
        }

        <span class="cov0" title="0">updatedData, err := json.Marshal(jsonValue)
        if err != nil </span><span class="cov0" title="0">{
                return oldRawDoc, err
        }</span>
        <span class="cov0" title="0">slog.Info("PATCHING 4", "updatedData", updatedData)

        return updatedData, nil</span>
}

// validatePatches validates a slice of PatchOperation objects to ensure that each operation is valid.
// It returns an error if any operation is not one of the allowed types: "ArrayAdd", "ArrayRemove", or "ObjectAdd".
func validatePatches(ops []PatchOperation) error <span class="cov8" title="1">{
        for _, p := range ops </span><span class="cov8" title="1">{
                if p.Op != "ArrayAdd" &amp;&amp; p.Op != "ArrayRemove" &amp;&amp; p.Op != "ObjectAdd" </span><span class="cov8" title="1">{
                        return fmt.Errorf("bad patch operation: %s", p.Op)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Package resourceCreatorService is responsible for the processing of any and all PUT/POST requests to the database, delegating and forwarding any and all requests
// to their appropriate user.
package resourceCreatorService

import (
        "encoding/json"
        "fmt"
        "log/slog"
        "math/rand/v2"
        "net/http"
        "strings"

        "github.com/RICE-COMP318-FALL24/owldb-p1group24/index_utils"
)

// Upsertdatabaser defines the interface for uploading collections and documents to a database.
type Upsertdatabaser interface {
        UploadCol(colpath string, dbName string) ([]byte, int, string)                                                                    // Uploads a collection to the database.
        UploadDocument(docpath string, payload []byte, docname, user string, overwrite, isPost bool, dbName string) ([]byte, int, string) // Uploads a document to the database.
}

// DatabaseIndex describes the necessary behaviors for the underlying container of the databases themselves
type DatabaseIndex[K string, V Upsertdatabaser] interface {
        Upsert(key K, check index_utils.UpdateCheck[K, V]) (updated bool, err error)
        Find(key K) (foundValue V, found bool)
}

// ResourceCreatorService is responsible for handling requests to create or upload collections and documents in the database.
type ResourceCreatorService[K string, T Upsertdatabaser] struct {
        dbs       DatabaseIndex[K, T] // The collection of databases.
        dbfactory DBFactory[T]        // A factory function for creating new databases.
        validator Validator           // Validates the schema of documents before uploading.
}

// Validator defines an interface for validating JSON data against a schema.
type Validator interface {
        Validate(jsonData []byte) error // Validates the given JSON data.
}

// New creates a new instance of a ResourceCreatorService. Note that the arguments passed in must themselves be initialized properly to ensure correct behavior
func New[K string, T Upsertdatabaser](dbs DatabaseIndex[K, T], dbfactory DBFactory[T], validator Validator) *ResourceCreatorService[K, T] <span class="cov8" title="1">{
        return &amp;ResourceCreatorService[K, T]{dbs: dbs, dbfactory: dbfactory, validator: validator}
}</span>

// PutCol will put a collection at the database dtb with collection path colpath.
// It returns a JSON-encoded response and a status code indicating success or failure.
func (rcs *ResourceCreatorService[K, T]) PutCol(dtb string, colpath string) ([]byte, int, string) <span class="cov8" title="1">{
        db, found := rcs.dbs.Find(K(dtb))

        if !found </span><span class="cov8" title="1">{
                errmsg, _ := json.Marshal("Error: no such database exists")
                return errmsg, http.StatusNotFound, ""
        }</span>

        <span class="cov8" title="1">return db.UploadCol(colpath, dtb)</span>
}

// DBFactory is a factory function for creating new databases.
// It returns a JSON-encoded response and a status code indicating success or failure.
type DBFactory[T Upsertdatabaser] func(string) T

// CreateDB creates a database with name dbName
func (rcs *ResourceCreatorService[K, T]) CreateDB(dbName string) ([]byte, int, string) <span class="cov8" title="1">{
        var nullDB T
        check := func(key K, curVal T, exists bool) (newVal T, err error) </span><span class="cov0" title="0">{
                if exists </span><span class="cov0" title="0">{
                        return nullDB, fmt.Errorf("database with that name exists")
                }</span>
                <span class="cov0" title="0">return rcs.dbfactory(string(key)), nil</span>
        }

        <span class="cov8" title="1">_, err := rcs.dbs.Upsert(K(dbName), check)
        if err != nil </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal(err.Error())
                return errmsg, http.StatusBadRequest, ""
        }</span>
        <span class="cov8" title="1">resp := struct {
                Uri string `json:"uri"`
        }{
                Uri: "/v1/" + string(dbName),
        }
        respSerial, _ := json.Marshal(resp)
        return respSerial, http.StatusCreated, resp.Uri</span>
}

// generateResourceName is an internal routine to generate the name of a resource
func generateResourceName() string <span class="cov8" title="1">{
        var name string
        validChars := "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-.~"
        leng := 12
        for i := 0; i &lt; leng; i++ </span><span class="cov8" title="1">{
                ch := rand.IntN(len(validChars))
                name += string(validChars[ch])
        }</span>
        <span class="cov8" title="1">return name</span>

}

// PostDoc posts a document to the database named dbName.
// Note that if the document is not a top-level document, the post is delegated
// to the parent document on the path to the child collection that will contain this new document
// returns a JSON-encoded response and a status code.
func (rcs *ResourceCreatorService[K, T]) PostDoc(dbName string, colpath string, user string, payload []byte) ([]byte, int, string) <span class="cov8" title="1">{
        colpath = strings.TrimSuffix(colpath, "/")
        db, found := rcs.dbs.Find(K(dbName))
        if !found </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal("Error adding document: Database does not exist.")
                return errmsg, http.StatusNotFound, ""

        }</span>
        <span class="cov8" title="1">validErr := rcs.validator.Validate(payload)
        if validErr != nil </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal("Malformed document, document does not conform to schema for reason")
                return errmsg, http.StatusBadRequest, ""
        }</span>

        <span class="cov8" title="1">docName := generateResourceName()
        slog.Debug(fmt.Sprintf("Generated name: %s", docName))
        docPath := docName
        if colpath != "" </span><span class="cov8" title="1">{
                docPath = colpath + "/" + docName
        }</span>
        <span class="cov8" title="1">slog.Debug(fmt.Sprintf("PostDoc: the path for this document is %s", docPath))

        return db.UploadDocument(docPath, payload, docName, user, true, true, string(dbName))</span>
}

// PutDoc puts a document in the database
// It returns a JSON-encoded response and a status code indicating success or failure.
func (rcs *ResourceCreatorService[K, T]) PutDoc(dbName K, docpath string, docname string, payload []byte, overwrite bool, user string) ([]byte, int, string) <span class="cov8" title="1">{
        db, found := rcs.dbs.Find(dbName)
        if !found </span><span class="cov8" title="1">{
                errmsg, _ := json.Marshal("Collection does not exist")
                return errmsg, http.StatusNotFound, ""

        }</span>

        <span class="cov8" title="1">validErr := rcs.validator.Validate(payload)
        if validErr != nil </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal("Malformed document, document does not conform to schema for reason")
                return errmsg, http.StatusBadRequest, ""
        }</span>
        <span class="cov8" title="1">slog.Debug(fmt.Sprintf("calling PutDoc with the following params: overwrite %t", overwrite))
        return db.UploadDocument(docpath, payload, docname, user, overwrite, false, string(dbName))</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Package resourceDeleterService is responsible for deleting resources held on OwlDB
package resourceDeleterService

import (
        "encoding/json"
        "log/slog"
        "net/http"
)

// Notifier is an interface that defines a method for notifying subscribers of changes to a resource.
type Notifier interface {
        NotifyAll(colname string)
}

// Deletedatabaser encompasses the behaviors needed for ResourceDeleterService to operate on
type Deletedatabaser interface {
        Notifier
        DeleteDoc(docpath string) ([]byte, int) //DeleteDoc should delete the document at the provided path
        DeleteCol(colpath string) ([]byte, int) //DeleteCol should delete the collection at the provided path
}

// DatabaseIndex is a generic interface that defines operations for managing databases.
type DatabaseIndex[K string, V Deletedatabaser] interface {
        Remove(key K) (removedVal V, removed bool)
        Find(key K) (foundVal V, found bool)
}

// ResourceDeleterService is responsible for the deletion of resources
type ResourceDeleterService[K string, V Deletedatabaser] struct {
        dbs DatabaseIndex[K, V]
}

// New creates a new ResourceDeleterService, ready to use as long as the dbs has been initialized.
func New[K string, T Deletedatabaser](dbs DatabaseIndex[K, T]) *ResourceDeleterService[K, T] <span class="cov8" title="1">{
        return &amp;ResourceDeleterService[K, T]{dbs: dbs}
}</span>

// DeleteDoc deletes the document located at the path docpath, under the database dbName
func (rds *ResourceDeleterService[K, T]) DeleteDoc(dbName string, docpath string) ([]byte, int) <span class="cov8" title="1">{
        dtb, found := rds.dbs.Find(K(dbName))

        if !found </span><span class="cov8" title="1">{
                errmsg, _ := json.Marshal("Error: database does not exist")
                return errmsg, http.StatusNotFound
        }</span>
        <span class="cov8" title="1">return dtb.DeleteDoc(docpath)</span>
}

// DeleteCol deletes the document loacted at the path colpath, under the database dtb
func (rds *ResourceDeleterService[K, T]) DeleteCol(dtb string, colpath string) ([]byte, int) <span class="cov8" title="1">{
        db, found := rds.dbs.Find(K(dtb))

        if !found </span><span class="cov8" title="1">{
                errmsg, _ := json.Marshal("Error: no such database exists")
                return errmsg, http.StatusNotFound
        }</span>

        <span class="cov8" title="1">return db.DeleteCol(colpath)</span>
}

// DeleteDB deletes the database named dtb. It returns a json-encoded response, and a status code
func (rds *ResourceDeleterService[K, T]) DeleteDB(dtb string) ([]byte, int) <span class="cov8" title="1">{
        db, success := rds.dbs.Remove(K(dtb))
        if success </span><span class="cov8" title="1">{
                msg, _ := json.Marshal("Deleted.")
                slog.Debug("About to notify subscribers that this database is deleted")
                db.NotifyAll("/")
                return msg, http.StatusNoContent
        }</span> else<span class="cov8" title="1"> {
                errmsg, _ := json.Marshal("Error: database does not exist")
                return errmsg, http.StatusNotFound
        }</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Package resourceGetterService serves to route get requests to the correct internal handlers, receiving their responses, and forwarding them back to the server
package resourceGetterService

import (
        "encoding/json"
        "fmt"
        "log/slog"
        "net/http"
)

type Getdatabaser interface {
        GetDocumentSerial(docpath string, isSubscribe bool) (payload []byte, subChannel *chan []byte, subId string, statusCode int, docEvent []byte)
        GetColSerial(colpath string, lo string, hi string, isSubscription bool) (payload []byte, stat_code int, subChan *chan []byte, subId string, docEvents [][]byte)
}

type DatabaseIndex[K string, V Getdatabaser] interface {
        Find(key K) (foundValue V, found bool)
}

type ResourceGetterService[K string, V Getdatabaser] struct {
        dbs DatabaseIndex[K, V]
}

func New[K string, V Getdatabaser](dbs DatabaseIndex[K, V]) *ResourceGetterService[K, V] <span class="cov8" title="1">{
        return &amp;ResourceGetterService[K, V]{dbs: dbs}
}</span>

func (rgs *ResourceGetterService[K, T]) GetCol(dtb string, colpath string, lower string, upper string, mode bool) (payload []byte, statCode int, subChan *chan []byte, subId string, docEvents [][]byte) <span class="cov8" title="1">{

        if mode </span><span class="cov0" title="0">{
                slog.Debug(fmt.Sprintf("Received subscription request"))
        }</span>

        <span class="cov8" title="1">db, found := rgs.dbs.Find(K(dtb))
        if !found </span><span class="cov8" title="1">{
                errmsg, _ := json.Marshal(fmt.Sprintf("Database does not exist"))
                return errmsg, http.StatusNotFound, subChan, subId, docEvents
        }</span>

        <span class="cov0" title="0">return db.GetColSerial(colpath, lower, upper, mode)</span>
}

func (rgs *ResourceGetterService[K, T]) GetDoc(dtb string, pathstr string, subscription bool) (response []byte, statCode int, subCh *chan []byte, id string, docEvent []byte) <span class="cov8" title="1">{

        if subscription </span><span class="cov0" title="0">{
                slog.Debug(fmt.Sprintf("Received a subscription request"))
        }</span>

        <span class="cov8" title="1">root, ok := rgs.dbs.Find(K(dtb))
        if !ok </span><span class="cov8" title="1">{
                errmsg, _ := json.Marshal("Error getting document: a database with that name does not exist.")
                return errmsg, http.StatusNotFound, nil, id, docEvent
        }</span>

        <span class="cov8" title="1">doc, subChan, subId, stat, docEv := root.GetDocumentSerial(pathstr, subscription)
        return doc, stat, subChan, subId, docEv</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package resourcePatcherService is responsible for processing and dispatching PATCH requests to their appropriate handlers
package resourcePatcherService

import (
        "github.com/RICE-COMP318-FALL24/owldb-p1group24/index_utils"
        "net/http"
)

// Patchdatabaser is an interface that represents an object capable of applying patches to documents.
type Patchdatabaser interface {
        Patch(docPath string, patches []byte, user string) ([]byte, int)
}

// DatabaseIndex is a generic interface that defines operations for managing databases.
type DatabaseIndex[K string, V Patchdatabaser] interface {
        // Upsert inserts or updates a value in the database index based on the given key and update function.
        Upsert(key K, check index_utils.UpdateCheck[K, V]) (updated bool, err error)

        // Find looks up a value based on the given key. It returns the found value and whether it was found.
        Find(key K) (foundValue V, found bool)
}

// Validator is an interface for validating data against a schema or set of rules.
type Validator interface {
        Validate([]byte) error
}

// ResourcePatcherService manages and processes PATCH operations for documents within databases.
type ResourcePatcherService[K string, T Patchdatabaser] struct {
        dbs DatabaseIndex[K, T]
}

// New creates a new instance of ResourcePatcherService with the given database index.
func New[K string, T Patchdatabaser](dbs DatabaseIndex[K, T]) *ResourcePatcherService[K, T] <span class="cov8" title="1">{
        return &amp;ResourcePatcherService[K, T]{dbs: dbs}
}</span>

// PatchDoc processes a PATCH request for a document within a specific database.
// Returns the response as a byte slice and the corresponding HTTP status code.
func (rps *ResourcePatcherService[K, T]) PatchDoc(dtb string, docpath string, patches []byte, user string) ([]byte, int, string) <span class="cov8" title="1">{

        db, found := rps.dbs.Find(K(dtb))
        if found == false </span><span class="cov8" title="1">{
                return []byte(`{"error": "Database not exist"}`), http.StatusNotFound, ""
        }</span> // find the database

        <span class="cov8" title="1">responses, status := db.Patch(docpath, patches, user)

        return responses, status, "/v1/" + dtb + "/" + docpath</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package server

import (
        "encoding/json"
        "io"
        "log/slog"
        "net/http"
)

func (dbh *DbHarness) loginhandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{

        body, err := io.ReadAll(r.Body)
        defer r.Body.Close()
        if err != nil </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal(err.Error())
                writeResponse(w, http.StatusBadRequest, errmsg)
                return

        }</span>

        <span class="cov8" title="1">var data struct {
                Username string `json:"username"`
        }
        err = json.Unmarshal(body, &amp;data)
        if err != nil </span><span class="cov8" title="1">{
                errmsg, _ := json.Marshal(err.Error())
                writeResponse(w, http.StatusBadRequest, errmsg)
                return
        }</span>
        <span class="cov8" title="1">if data.Username == "" </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal("No username found")
                writeResponse(w, http.StatusBadRequest, errmsg)
                return
        }</span>
        <span class="cov8" title="1">token, loginerr := dbh.auth.Login(data.Username)
        if loginerr != nil </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal(loginerr.Error())
                writeResponse(w, http.StatusBadRequest, errmsg)
                return
        }</span>
        <span class="cov8" title="1">response, _ := json.Marshal(struct {
                Token string `json:"token"`
        }{token})

        writeResponse(w, http.StatusOK, response)</span>
}

func (dbh *DbHarness) logoutHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        defer r.Body.Close()
        slog.Info("Delete Handler - Checking Authorization Header")

        // Check if the Authorization header is present
        slog.Info("Checking Authorization Header", "header", r.Header)

        // Extract token from the Authorization header
        token, err := extractToken(r.Header)
        if err != nil </span><span class="cov8" title="1">{
                slog.Warn("Authorization header missing or invalid", "error", err)
                errmsg, _ := json.Marshal(err.Error())
                writeResponse(w, http.StatusUnauthorized, errmsg)
                return
        }</span>
        <span class="cov8" title="1">slog.Debug("trying to logout?")
        slog.Info("Authorization Header Received", "token", token)

        // Perform logout
        loggedOut, err := dbh.auth.Logout(token)
        if err != nil || !loggedOut </span><span class="cov0" title="0">{
                slog.Warn("Logout failed", "error", err)
                errmsg, _ := json.Marshal("Missing or invalid bearer token")
                writeResponse(w, http.StatusUnauthorized, errmsg)
                return
        }</span>

        <span class="cov8" title="1">slog.Info("Successfully logged out", "token", token)
        w.Header().Set("Content-Type", "application/json")
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.WriteHeader(http.StatusNoContent)</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package server

import (
        "encoding/json"
        "fmt"
        "io"
        "log/slog"
        "net/http"
        "strings"
)

// putHandler dispatches PUT requests based on the end of the path; a terminating slash will redirect to collections, and documents otherwise
func (dbh *DbHarness) putHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{

        resource := r.PathValue("resource")
        if len(resource) == 0 </span><span class="cov0" title="0">{
                emsg, _ := json.Marshal("Bad Resource Path")
                writeResponse(w, http.StatusBadRequest, emsg)
                return
        }</span>
        <span class="cov8" title="1">splitPath := strings.Split(resource, "/")
        if len(splitPath) == 1 </span><span class="cov8" title="1">{
                dbh.createDBHandler(w, r)
                return
        }</span>
        <span class="cov8" title="1">if strings.HasSuffix(resource, "/") </span><span class="cov8" title="1">{
                dbh.putColHandler(w, r)
        }</span> else<span class="cov8" title="1"> {
                dbh.putDocHandler(w, r)
        }</span>
}

// createDBHandler handles requests to create databases
func (dbh *DbHarness) createDBHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        defer r.Body.Close()
        patherr := validateUrl(r.URL.Path) //validates path

        if patherr != nil </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal(patherr.Error())
                writeResponse(w, http.StatusBadRequest, errmsg)
                return
        }</span>
        <span class="cov8" title="1">token, err := extractToken(r.Header)
        if err != nil </span><span class="cov0" title="0">{
                emg, e := json.Marshal("Invalid or Expired Bearer token")
                if e != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Internal error", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov0" title="0">writeResponse(w, http.StatusUnauthorized, emg)</span>
        }

        <span class="cov8" title="1">_, autherr := dbh.auth.ValidateSession(token)
        if autherr != nil </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal(autherr.Error())
                writeResponse(w, http.StatusUnauthorized, errmsg)
                return
        }</span>

        <span class="cov8" title="1">dbName := r.PathValue("resource")
        if dbName == "" </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal("bad resource path")
                writeResponse(w, http.StatusBadRequest, errmsg)
                return
        }</span>
        <span class="cov8" title="1">response, status, uri := dbh.rc.CreateDB(dbName)
        if status == http.StatusCreated </span><span class="cov8" title="1">{
                w.Header().Set("Location", uri)
                writeResponse(w, status, response)
                return
        }</span>
        <span class="cov0" title="0">writeResponse(w, status, response)</span>
}

// putDocHandler handles putting new documents
func (dbh *DbHarness) putDocHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        defer r.Body.Close()
        patherr := validateUrl(r.URL.Path)

        if patherr != nil </span><span class="cov0" title="0">{
                errmsg, e := json.Marshal(patherr.Error())
                if e != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Internal server error", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov0" title="0">writeResponse(w, http.StatusBadRequest, errmsg)
                return</span>
        }
        //parse database name
        <span class="cov8" title="1">resourcePath := r.PathValue("resource")
        dbName, docPath := parseResourcePath(resourcePath)

        err := validateDocPath(docPath)
        if err != nil </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal(err.Error())
                writeResponse(w, http.StatusBadRequest, errmsg)
                return
        }</span>
        <span class="cov8" title="1">body, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Error: unable to read body", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">ok := json.Valid(body)
        if !ok </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal("Malformed json object")
                writeResponse(w, http.StatusBadRequest, errmsg)
                return
        }</span>
        <span class="cov8" title="1">splitPath := strings.Split(docPath, "/")
        params := r.URL.Query()
        isOverwrite := params.Get("mode")
        if isOverwrite != "" </span><span class="cov8" title="1">{
                if !validateOverwrite(isOverwrite) </span><span class="cov0" title="0">{
                        errmsg, _ := json.Marshal("Malformed overwrite parameter")
                        writeResponse(w, http.StatusBadRequest, errmsg)
                }</span>
        }

        <span class="cov8" title="1">var overwrite bool
        if isOverwrite == "nooverwrite" </span><span class="cov8" title="1">{
                overwrite = false
        }</span> else<span class="cov8" title="1"> {
                overwrite = true
        }</span>

        <span class="cov8" title="1">token, err := extractToken(r.Header)
        if err != nil </span><span class="cov8" title="1">{
                emg, e := json.Marshal("Invalid or Expired Bearer token")
                if e != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Internal error", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">writeResponse(w, http.StatusUnauthorized, emg)
                return</span>
        }
        <span class="cov8" title="1">slog.Debug(fmt.Sprintf("overwrite is %t", overwrite))
        user, autherr := dbh.auth.ValidateSession(token)
        if autherr != nil </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal(autherr.Error())
                writeResponse(w, http.StatusUnauthorized, errmsg)
                return
        }</span>
        <span class="cov8" title="1">err = validateDocPath(docPath)
        if err != nil </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal(err.Error())
                writeResponse(w, http.StatusBadRequest, errmsg)
                return
        }</span>
        <span class="cov8" title="1">response, status, uri := dbh.rc.PutDoc(dbName, docPath, splitPath[len(splitPath)-1], body, overwrite, user)
        if status == http.StatusCreated || status == http.StatusOK </span><span class="cov8" title="1">{
                w.Header().Set("Location", uri)
                writeResponse(w, status, response)
                return
        }</span>
        <span class="cov8" title="1">writeResponse(w, status, response)</span>
}

// postDocHandler handles all operations related to posting
func (dbh *DbHarness) postDocHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        defer r.Body.Close()

        patherr := validateUrl(r.URL.Path)

        if patherr != nil </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal(patherr.Error())
                writeResponse(w, http.StatusBadRequest, errmsg)
                return
        }</span>
        <span class="cov8" title="1">resourcePath := r.PathValue("resource")
        dbName, colpath := parseResourcePath(resourcePath)

        if !strings.HasSuffix(r.URL.Path, "/") </span><span class="cov8" title="1">{
                errmsg, _ := json.Marshal("Bad Resource Path")
                writeResponse(w, http.StatusBadRequest, errmsg)
                return
        }</span>
        <span class="cov8" title="1">if e := validateColPath(colpath); e != nil </span><span class="cov8" title="1">{
                errmsg, _ := json.Marshal("Bad Resource Path")
                writeResponse(w, http.StatusBadRequest, errmsg)
                return
        }</span>
        <span class="cov8" title="1">body, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal(err.Error())
                writeResponse(w, http.StatusBadRequest, errmsg)
                return
        }</span>
        <span class="cov8" title="1">ok := json.Valid(body)
        if !ok </span><span class="cov8" title="1">{
                errmsg, _ := json.Marshal("Bad JSON")
                writeResponse(w, http.StatusBadRequest, errmsg)
                return
        }</span>
        <span class="cov8" title="1">token, err := extractToken(r.Header)
        if err != nil </span><span class="cov8" title="1">{
                emg, e := json.Marshal("Missing or invalid bearer token")
                if e != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Internal error", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">writeResponse(w, http.StatusUnauthorized, emg)</span>
        }

        <span class="cov8" title="1">user, autherr := dbh.auth.ValidateSession(token)
        if autherr != nil </span><span class="cov0" title="0">{

                resp, _ := json.Marshal("Missing or invalid bearer token")
                writeResponse(w, http.StatusUnauthorized, resp)
                return
        }</span>
        <span class="cov8" title="1">resp, stat, uri := dbh.rc.PostDoc(dbName, colpath, user, body)
        if stat == http.StatusCreated </span><span class="cov8" title="1">{
                w.Header().Set("Location", uri)
        }</span>
        <span class="cov8" title="1">writeResponse(w, stat, resp)</span>

}

// putColHandler processes put operations on collections
func (dbh *DbHarness) putColHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        defer r.Body.Close()
        patherr := validateUrl(r.URL.Path)

        if patherr != nil </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal(patherr.Error())
                writeResponse(w, http.StatusBadRequest, errmsg)
                return
        }</span>
        <span class="cov8" title="1">resourcePath := r.PathValue("resource")
        dtb, colpath := parseResourcePath(resourcePath)

        err := validatePutColPath(colpath)
        if err != nil </span><span class="cov8" title="1">{
                errmsg, _ := json.Marshal(err.Error())
                writeResponse(w, http.StatusBadRequest, errmsg)
                return
        }</span>
        <span class="cov8" title="1">token, err := extractToken(r.Header)
        if err != nil </span><span class="cov0" title="0">{
                emg, _ := json.Marshal("Invalid or Expired Bearer token")

                writeResponse(w, http.StatusUnauthorized, emg)
        }</span>
        <span class="cov8" title="1">_, autherr := dbh.auth.ValidateSession(token)
        if autherr != nil </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal(autherr.Error())
                writeResponse(w, http.StatusUnauthorized, errmsg)
                return
        }</span>

        <span class="cov8" title="1">resp, stat, uri := dbh.rc.PutCol(dtb, colpath)
        if stat == http.StatusCreated </span><span class="cov8" title="1">{
                w.Header().Set("Location", uri)
                writeResponse(w, stat, resp)
                return
        }</span>
        <span class="cov0" title="0">writeResponse(w, stat, resp)</span>
}

// patchDocHanlder handles patch requests by parsing the url and forwarding them to the resourcepatcher service
func (dbh *DbHarness) patchDocHanlder(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        defer request.Body.Close()
        writer.Header().Set("Access-Control-Allow-Origin", "*")
        writer.Header().Set("Content-Type", "application/json")
        path := request.PathValue("resource")
        dbName, docPath := parseResourcePath(path)
        if dbName == "" </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal("Bad resource path")
                writeResponse(writer, http.StatusBadRequest, errmsg)
                return
        }</span>
        <span class="cov8" title="1">body, err := io.ReadAll(request.Body)
        if err != nil </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal(err.Error())
                writeResponse(writer, http.StatusBadRequest, errmsg)
                return
        }</span>
        <span class="cov8" title="1">ok := json.Valid(body)
        if !ok </span><span class="cov8" title="1">{
                errmsg, _ := json.Marshal("Not a valid json object")
                writeResponse(writer, http.StatusBadRequest, errmsg)
                return
        }</span>
        <span class="cov8" title="1">token, err := extractToken(request.Header)
        if err != nil </span><span class="cov8" title="1">{
                emg, e := json.Marshal("Missing or invalid Bearer token")
                if e != nil </span><span class="cov0" title="0">{
                        http.Error(writer, "Internal error", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">writeResponse(writer, http.StatusUnauthorized, emg)
                return</span>
        }
        <span class="cov8" title="1">user, autherr := dbh.auth.ValidateSession(token)
        if autherr != nil </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal(autherr.Error())
                writeResponse(writer, http.StatusUnauthorized, errmsg)
                return
        }</span>
        <span class="cov8" title="1">err = validateDocPath(docPath) //check that this is a valid document path
        if err != nil </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal(err.Error())
                writeResponse(writer, http.StatusBadRequest, errmsg)
                return
        }</span>
        <span class="cov8" title="1">resp, status, uri := dbh.rp.PatchDoc(dbName, docPath, body, user)
        if status == http.StatusOK </span><span class="cov8" title="1">{
                writer.Header().Set("Location", uri)
        }</span>
        <span class="cov8" title="1">writeResponse(writer, status, resp)</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package server

import (
        "encoding/json"
        "net/http"
        "strings"
)

// deleteHandler parses the resource path and dispatches requests accordingly
func (dbh *DbHarness) deleteHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        resource := r.PathValue("resource")
        if len(resource) == 0 </span><span class="cov0" title="0">{ //empty strings are not allowed
                emsg, _ := json.Marshal("Bad Resource Path")
                writeResponse(w, http.StatusBadRequest, emsg)
                return
        }</span>
        <span class="cov8" title="1">splitPath := strings.Split(resource, "/")
        if len(splitPath) == 1 </span><span class="cov8" title="1">{ //must be a database
                dbh.deleteDBHandler(w, r)
                return
        }</span>
        <span class="cov8" title="1">if strings.HasSuffix(resource, "/") </span><span class="cov8" title="1">{ //must be a collection
                dbh.deleteColHandler(w, r)
        }</span> else<span class="cov8" title="1"> {
                dbh.deleteDocHandler(w, r) //must be a document
        }</span>
}

// deleteColHandler handles delete requests to collections
func (dbh *DbHarness) deleteColHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        defer r.Body.Close()
        patherr := validateUrl(r.URL.Path)

        if patherr != nil </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal(patherr.Error())
                writeResponse(w, http.StatusBadRequest, errmsg)
                return
        }</span>
        <span class="cov8" title="1">token, err := extractToken(r.Header)
        if err != nil </span><span class="cov8" title="1">{
                errmsg, _ := json.Marshal(err.Error())
                writeResponse(w, http.StatusUnauthorized, errmsg)
                return
        }</span>
        <span class="cov8" title="1">_, autherr := dbh.auth.ValidateSession(token)
        if autherr != nil </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal(autherr.Error())
                writeResponse(w, http.StatusUnauthorized, errmsg)
                return
        }</span>
        <span class="cov8" title="1">resourcePath := r.PathValue("resource")
        dbName, colpath := parseResourcePath(resourcePath)
        err = validateColPath(colpath)
        if err != nil </span><span class="cov8" title="1">{
                errmsg, e := json.Marshal(err.Error())
                if e != nil </span><span class="cov0" title="0">{
                        http.Error(w, e.Error(), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">writeResponse(w, http.StatusBadRequest, errmsg)
                return</span>
        }
        <span class="cov8" title="1">response, status := dbh.rd.DeleteCol(dbName, colpath)
        writeResponse(w, status, response)</span>
}

// deleteDocHandler handles deletions for documents
func (dbh *DbHarness) deleteDocHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        defer r.Body.Close()
        patherr := validateUrl(r.URL.Path)

        if patherr != nil </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal(patherr.Error())
                writeResponse(w, http.StatusBadRequest, errmsg)
                return
        }</span>
        <span class="cov8" title="1">token, err := extractToken(r.Header)
        if err != nil </span><span class="cov8" title="1">{
                emg, e := json.Marshal("Invalid or Expired Bearer token")
                if e != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Internal error", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">writeResponse(w, http.StatusUnauthorized, emg)
                return</span>
        }

        <span class="cov8" title="1">_, autherr := dbh.auth.ValidateSession(token)
        if autherr != nil </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal(autherr.Error())
                writeResponse(w, http.StatusUnauthorized, errmsg)
                return
        }</span>
        <span class="cov8" title="1">path := r.PathValue("resource")
        dbName, docpath := parseResourcePath(path)
        err = validateDocPath(docpath)
        if err != nil </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal(err.Error())
                writeResponse(w, http.StatusBadRequest, errmsg)
                return
        }</span>
        <span class="cov8" title="1">response, status := dbh.rd.DeleteDoc(dbName, docpath)
        writeResponse(w, status, response)</span>
}

// deleteDBHandler handles requests to delete databases
func (dbh *DbHarness) deleteDBHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        defer r.Body.Close()
        patherr := validateUrl(r.URL.Path) //validating that the path is well-formed

        if patherr != nil </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal(patherr.Error())
                writeResponse(w, http.StatusBadRequest, errmsg)
                return
        }</span>

        <span class="cov8" title="1">dbName := r.PathValue("resource")
        token, err := extractToken(r.Header)
        if err != nil </span><span class="cov8" title="1">{
                emg, e := json.Marshal("Invalid or Expired Bearer token")
                if e != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Internal error", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">writeResponse(w, http.StatusUnauthorized, emg)
                return</span>
        }
        <span class="cov8" title="1">_, autherr := dbh.auth.ValidateSession(token) //authenticating
        if autherr != nil </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal(autherr.Error())
                writeResponse(w, http.StatusUnauthorized, errmsg)
                return
        }</span>

        <span class="cov8" title="1">response, status := dbh.rd.DeleteDB(dbName)

        writeResponse(w, status, response)</span>

}
</pre>
		
		<pre class="file" id="file22" style="display: none">package server

import (
        "bytes"
        "encoding/json"
        "fmt"
        "log/slog"
        "net/http"
        "strings"
        "time"
)

// a writeFlusher is the composition of an http.ResponseWriter and the http.Flusher. Needed for SSEs
type writeFlusher interface {
        http.ResponseWriter
        http.Flusher
}

// getHandler dispatches get requests depending on whether they end with a /
func (dbh *DbHarness) getHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        resource := r.PathValue("resource")
        if len(resource) == 0 </span><span class="cov0" title="0">{
                emsg, _ := json.Marshal("Bad Resource Path")
                writeResponse(w, http.StatusBadRequest, emsg)
                return
        }</span>
        <span class="cov8" title="1">splitPath := strings.Split(resource, "/")
        if len(splitPath) == 1 </span><span class="cov8" title="1">{
                dbh.getDocHandler(w, r)
                return
        }</span>
        <span class="cov8" title="1">if strings.HasSuffix(resource, "/") </span><span class="cov8" title="1">{
                dbh.getColHandler(w, r)
        }</span> else<span class="cov8" title="1"> {
                dbh.getDocHandler(w, r)
        }</span>
}

func (dbh *DbHarness) getDocHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        defer r.Body.Close()
        patherr := validateUrl(r.URL.Path)

        if patherr != nil </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal(patherr.Error())
                writeResponse(w, http.StatusBadRequest, errmsg)
                return
        }</span>
        <span class="cov8" title="1">token, err := extractToken(r.Header)
        if err != nil </span><span class="cov0" title="0">{
                ermsg, _ := json.Marshal("Missing or invalid bearer token")
                writeResponse(w, http.StatusUnauthorized, ermsg)
                return
        }</span>

        <span class="cov8" title="1">_, autherr := dbh.auth.ValidateSession(token)
        if autherr != nil </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal(autherr.Error())
                writeResponse(w, http.StatusUnauthorized, errmsg)
                return
        }</span>
        <span class="cov8" title="1">qs := r.URL.Query()
        mode := qs.Get("mode")
        subscribe := (mode == "subscribe")
        if mode != "" </span><span class="cov8" title="1">{
                if !validateSubscribe(mode) </span><span class="cov8" title="1">{
                        writeError(w, http.StatusBadRequest, fmt.Errorf("malformed mode query parameter"))
                        return
                }</span>
        }

        <span class="cov8" title="1">path := r.PathValue("resource")
        dtb, docpath := parseResourcePath(path)
        err = validateDocPath(docpath)
        if err != nil </span><span class="cov8" title="1">{
                errmsg, e := json.Marshal(err.Error())
                if e != nil </span><span class="cov0" title="0">{
                        http.Error(w, "internal error", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">writeResponse(w, http.StatusBadRequest, errmsg)
                return</span>
        }
        <span class="cov8" title="1">response, status, subChan, _, docEv := dbh.rg.GetDoc(dtb, docpath, subscribe)
        if status != http.StatusOK </span><span class="cov0" title="0">{
                writeResponse(w, status, response)
                return
        }</span>
        <span class="cov8" title="1">if subscribe &amp;&amp; status == http.StatusOK </span><span class="cov0" title="0">{
                wf, ok := w.(writeFlusher)
                if !ok </span><span class="cov0" title="0">{
                        http.Error(w, "streaming unsupported", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov0" title="0">wf.Header().Set("Content-Type", "text/event-stream")
                wf.Header().Set("Cache-Control", "no-cache")
                wf.Header().Set("Connection", "keep-alive")
                wf.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, Last-Event-ID")
                wf.Header().Set("Access-Control-Allow-Origin", "*")
                wf.WriteHeader(http.StatusOK)
                wf.Flush()
                var evt bytes.Buffer
                evt.WriteString(string(docEv))

                slog.Info("Sending", "msg", evt.String())

                // Send event
                wf.Write(evt.Bytes())
                wf.Flush()
                ticker := time.NewTicker(15 * time.Second)
                defer ticker.Stop()
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                var evt bytes.Buffer
                                evt.WriteString(":keep-alive\n\n")
                                wf.Write(evt.Bytes())
                                wf.Flush()</span>
                        case &lt;-r.Context().Done():<span class="cov0" title="0">

                                continue</span>
                        case event := &lt;-*subChan:<span class="cov0" title="0">
                                var evt bytes.Buffer
                                evt.WriteString(string(event))

                                slog.Info("Sending", "msg", evt.String())

                                // Send event
                                wf.Write(evt.Bytes())
                                wf.Flush()</span>
                        }

                }
        }
        <span class="cov8" title="1">writeResponse(w, status, response)</span>
}

func (dbh *DbHarness) getColHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        defer r.Body.Close()
        slog.Info(fmt.Sprintf("Request headers: %+v", r.Context()))
        patherr := validateUrl(r.URL.Path)

        if patherr != nil </span><span class="cov0" title="0">{
                http.Error(w, patherr.Error(), http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">token, err := extractToken(r.Header)
        if err != nil </span><span class="cov0" title="0">{
                emg, e := json.Marshal("Invalid or Expired Bearer token")
                if e != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Internal error", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov0" title="0">writeResponse(w, http.StatusUnauthorized, emg)
                return</span>
        }
        <span class="cov8" title="1">_, autherr := dbh.auth.ValidateSession(token)
        if autherr != nil </span><span class="cov0" title="0">{
                errmsg, _ := json.Marshal(autherr.Error())
                writeResponse(w, http.StatusUnauthorized, errmsg)
                return
        }</span>
        <span class="cov8" title="1">path := r.PathValue("resource")
        dtb, colpath := parseResourcePath(path)

        err = validateColPath(colpath)
        if err != nil </span><span class="cov8" title="1">{
                errmsg, e := json.Marshal(err.Error())
                if e != nil </span><span class="cov0" title="0">{
                        http.Error(w, "internal error", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">writeResponse(w, http.StatusBadRequest, errmsg)
                return</span>
        }
        <span class="cov8" title="1">qs := r.URL.Query()
        mode := qs.Get("mode")
        subscribe := (mode == "subscribe")
        if mode != "" </span><span class="cov8" title="1">{
                if !validateSubscribe(mode) </span><span class="cov8" title="1">{
                        errmsg, e := json.Marshal("Malformed subscribe param")
                        if e != nil </span><span class="cov0" title="0">{
                                http.Error(w, e.Error(), http.StatusInternalServerError)
                                return
                        }</span>
                        <span class="cov8" title="1">writeResponse(w, http.StatusBadRequest, errmsg)

                        return</span>
                }
        }

        <span class="cov8" title="1">bounds := qs.Get("interval")
        if bounds != "" </span><span class="cov8" title="1">{
                if !validateBounds(bounds) </span><span class="cov8" title="1">{
                        errmsg, _ := json.Marshal("Malformed interval param")
                        writeResponse(w, http.StatusBadRequest, errmsg)

                        return
                }</span>
        }

        <span class="cov8" title="1">lower, upper := parseBounds(bounds)
        slog.Debug(fmt.Sprintf("These are the bounds received: %s lower, %s upper", lower, upper))
        b, status, subChan, _, docEvents := dbh.rg.GetCol(dtb, colpath, lower, upper, subscribe)
        slog.Debug(fmt.Sprintf("%d", status))
        if subscribe &amp;&amp; status == http.StatusOK </span><span class="cov8" title="1">{ //subscription request
                wf, ok := w.(writeFlusher)
                slog.Debug(fmt.Sprintf("Beginning sse connection, payload is %s", string(b)))
                if !ok </span><span class="cov0" title="0">{
                        http.Error(w, "streaming unsupported", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">wf.Header().Set("Content-Type", "text/event-stream")
                wf.Header().Set("Cache-Control", "no-cache")
                wf.Header().Set("Connection", "keep-alive")
                wf.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, Last-Event-ID")
                wf.Header().Set("Access-Control-Allow-Origin", "*")
                wf.WriteHeader(http.StatusOK)
                wf.Flush()
                ticker := time.NewTicker(15 * time.Second) //keep-alive comments
                defer ticker.Stop()
                for _, ev := range docEvents </span><span class="cov0" title="0">{ //writing each document as an SSE
                        var evt bytes.Buffer
                        evt.WriteString(string(ev))

                        slog.Info("Sending", "msg", evt.String())

                        // Send event
                        wf.Write(evt.Bytes())
                        wf.Flush()
                }</span>
                <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                        select </span>{

                        case &lt;-ticker.C:<span class="cov0" title="0"> //send a comment
                                var evt bytes.Buffer
                                evt.WriteString(":keep-alive\n\n")
                                wf.Write(evt.Bytes())
                                wf.Flush()</span>

                        case &lt;-r.Context().Done():<span class="cov0" title="0">

                                continue</span>
                        case event := &lt;-*subChan:<span class="cov0" title="0">
                                var evt bytes.Buffer
                                evt.WriteString(string(event))

                                slog.Info("Sending", "msg", evt.String())

                                // Send event
                                wf.Write(evt.Bytes())
                                wf.Flush()</span>
                        }

                }

        } else<span class="cov8" title="1"> { //not a subscription request
                writeResponse(w, status, b)
        }</span>

}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Package server Description: This file contains the implementation of the HTTP server that serves the API.
package server

import (
        "log/slog"
        "net/http"
)

type resourceCreator interface {
        PostDoc(dbName string, colpath string, user string, payload []byte) ([]byte, int, string)
        PutDoc(dbName string, docpath string, docname string, payload []byte, overwrite bool, user string) ([]byte, int, string)
        PutCol(dtb string, colpath string) ([]byte, int, string)
        CreateDB(dbName string) ([]byte, int, string)
}

type resourceGetter interface {
        GetDoc(dtb string, pathstr string, subscription bool) (response []byte, statCode int, subCh *chan []byte, id string, docEvent []byte)

        GetCol(dtb string, colpath string, lower string, upper string, mode bool) (payload []byte, statCode int, subChan *chan []byte, subId string, docEvents [][]byte)
}

type resourceDeleter interface {
        DeleteCol(dtb string, colpath string) ([]byte, int)
        DeleteDoc(dbName string, docpath string) ([]byte, int)
        DeleteDB(dbName string) ([]byte, int)
}

type resourcePatcher interface {
        PatchDoc(dtb string, docpath string, patches []byte, user string) ([]byte, int, string)
}

// DbHarness serves as a structure that exposes the resource services to HTTP endpoints
type DbHarness struct {
        rg   resourceGetter  //rg manages all requests to GET resources
        rd   resourceDeleter //rd manages all requests to DELETE resources
        rc   resourceCreator //rc manages all requests to PUT &amp; POST resources
        rp   resourcePatcher //rp manages all requests to PATCH resources
        auth Authorizer      //auth manages all authorization mechanisms
}

// Authorizer encapsulates the necessary functionalities for authentication
type Authorizer interface {
        CreateSession(username string) (string, error) //creates a session
        ValidateSession(token string) (string, error)  //validates a session
        Login(username string) (string, error)         //logs in
        Logout(token string) (bool, error)             //logs out
}

// New creates a new HTTP server, taking a resourceDeleter, resourceGetter, and resourceCreator
func New(rd resourceDeleter, rg resourceGetter, rc resourceCreator, auth Authorizer, rp resourcePatcher) http.Handler <span class="cov8" title="1">{

        dbharness := DbHarness{
                rg:   rg,
                rd:   rd,
                rc:   rc,
                rp:   rp,
                auth: auth,
        }

        mux := http.NewServeMux()

        mux.HandleFunc("PUT /v1/{resource...}", dbharness.putHandler)
        mux.HandleFunc("GET /v1/{resource...}", dbharness.getHandler)
        mux.HandleFunc("POST /v1/{resource...}", dbharness.postDocHandler)
        mux.HandleFunc("PATCH /v1/{resource...}", dbharness.patchDocHanlder)
        mux.HandleFunc("DELETE /v1/{resource...}", dbharness.deleteHandler)

        mux.HandleFunc("OPTIONS /auth", authOptionsHandler)
        mux.HandleFunc("OPTIONS /v1/", optionsHandler)
        mux.HandleFunc("POST /auth", dbharness.loginhandler)
        mux.HandleFunc("DELETE /auth", dbharness.logoutHandler)

        return requestPreprocessor(mux)
}</span>

// optionsHandler is needed to handle preflighted requests; the swagger testing thing
// sends an OPTIONS request before anything else
func optionsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Allow", "GET, POST, PUT, DELETE, OPTIONS, PATCH")
        w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS, PATCH")
        w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

        w.WriteHeader(http.StatusOK)
}</span>

// defaultOptionsHandler handles all OPTIONS requests to invalid URLs. Since no methods
// are allowed on invalid requests, no allowed methods are returned
func defaultOptionsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        slog.Debug("hello from default options")
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Allow", "")
        w.Header().Set("Access-Control-Allow-Methods", "")
        w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
        w.WriteHeader(http.StatusOK)
}</span>

// authOptionsHandler handles OPTIONS requests to the auth endpoint.
func authOptionsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Allow", "POST, DELETE, OPTIONS")
        w.Header().Set("Access-Control-Allow-Methods", "POST, DELETE, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

        w.WriteHeader(http.StatusOK)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package server

import (
        "encoding/json"
        "errors"
        "fmt"
        "log/slog"
        "net/http"
        "regexp"
        "strings"
)

//type muxForwarder struct {
//        mux *http.ServeMux
//}
//
//func (mF *muxForwarder) ServeHTTP(w http.ResponseWriter, r *http.Request) {
//        handler, match := mF.mux.Handler(r)
//        if match != r.URL.Path {
//                emsg, _ := json.Marshal("Bad Resource Path")
//                writeResponse(w, http.StatusBadRequest, emsg)
//                return
//        }
//        if match == "" {
//                emsg, _ := json.Marshal("Bad Resource Path")
//                writeResponse(w, http.StatusBadRequest, emsg)
//                return
//        }
//        handler.ServeHTTP(w, r)
//}

func writeResponse(w http.ResponseWriter, code int, response []byte) <span class="cov8" title="1">{
        if code != http.StatusNoContent </span><span class="cov8" title="1">{
                w.Header().Set("Content-Type", "application/json")
                w.Header().Set("Access-Control-Allow-Origin", "*")
                w.WriteHeader(code)
                w.Write(response)
        }</span> else<span class="cov8" title="1"> {
                w.Header().Set("Access-Control-Allow-Origin", "*")
                w.WriteHeader(code)
        }</span>

}

func writeError(w http.ResponseWriter, code int, err error) <span class="cov8" title="1">{
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.WriteHeader(code)
        //w.Header().Set("Content-Type", "application/json")
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Write([]byte(err.Error()))
}</span>

func extractToken(header http.Header) (string, error) <span class="cov8" title="1">{
        authHeader := header.Get("Authorization")
        if authHeader == "" </span><span class="cov8" title="1">{
                return "", errors.New("authorization header missing")
        }</span>

        <span class="cov8" title="1">token := strings.TrimPrefix(authHeader, "Bearer ")
        if token == "" </span><span class="cov0" title="0">{
                return "", errors.New("invalid authorization token format")
        }</span>

        <span class="cov8" title="1">return token, nil</span>
}

func validateBounds(param string) bool <span class="cov8" title="1">{
        pattern := "^(\\[|\\()[^[\\]()]*,[^[\\]()]*(\\]|\\))$"
        match, err := regexp.MatchString(pattern, param)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if match </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func validateSubscribe(param string) bool <span class="cov8" title="1">{
        pattern := "^(no)?subscribe$"
        match, err := regexp.MatchString(pattern, param)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if match </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func validateOverwrite(param string) bool <span class="cov8" title="1">{
        pattern := "^(no)?overwrite$"
        match, err := regexp.MatchString(pattern, param)

        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if !match </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

func validateColPath(colpath string) error <span class="cov8" title="1">{
        if colpath == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">c2 := strings.TrimSuffix(colpath, "/")

        splitPath := strings.Split(c2, "/")

        if len(splitPath)%2 != 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("bad resource path")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func requestPreprocessor(mx http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                if r.Method == "OPTIONS" </span><span class="cov8" title="1">{
                        if strings.HasPrefix(r.URL.Path, "/v1/") </span><span class="cov8" title="1">{
                                optionsHandler(w, r)
                        }</span> else<span class="cov8" title="1"> if r.URL.Path == "/auth" </span><span class="cov8" title="1">{
                                authOptionsHandler(w, r)
                        }</span> else<span class="cov8" title="1"> {
                                defaultOptionsHandler(w, r)
                        }</span>
                        <span class="cov8" title="1">return</span>
                }

                <span class="cov8" title="1">if strings.Contains(r.URL.Path, "//") </span><span class="cov8" title="1">{
                        errmsg, err := json.Marshal("Bad Uri: contains //")
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(w, "Internal server error", http.StatusInternalServerError)
                                return
                        }</span>
                        <span class="cov8" title="1">writeResponse(w, http.StatusBadRequest, errmsg)
                        return</span>
                }

                <span class="cov8" title="1">mx.ServeHTTP(w, r)</span>
        })
}

// validatePutColPath validates paths for put requests for collections
func validatePutColPath(path string) error <span class="cov8" title="1">{
        if path == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("Bad Uri")
        }</span>
        <span class="cov8" title="1">c2 := strings.TrimSuffix(path, "/")
        sp := strings.Split(c2, "/")
        if len(sp)%2 != 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("Bad Uri")

        }</span>
        <span class="cov8" title="1">return nil</span>
}

func parseResourcePath(path string) (database string, resourcePath string) <span class="cov8" title="1">{
        splitPath := strings.Split(path, "/")
        if len(splitPath) == 1 </span><span class="cov8" title="1">{
                return splitPath[0], ""
        }</span>
        <span class="cov8" title="1">resourcePath = strings.TrimPrefix(path, splitPath[0]+"/")
        return splitPath[0], resourcePath</span>
}

func validateDocPath(docpath string) error <span class="cov8" title="1">{
        if docpath == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("bad resource path")
        }</span>
        <span class="cov8" title="1">splitPath := strings.Split(docpath, "/")
        if len(splitPath)%2 != 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("bad resource path")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// parseBounds is an internal helper routine to parse the interval parameter. Returns the upper and lower bounds
func parseBounds(rawBounds string) (string, string) <span class="cov8" title="1">{
        if rawBounds == "[,]" || rawBounds == "" </span><span class="cov8" title="1">{
                return string(rune(0)), string(rune(127))
        }</span>
        <span class="cov8" title="1">rawBounds = strings.Trim(rawBounds, "[]")

        splitStr := strings.Split(rawBounds, ",")
        var lower string
        var upper string
        if splitStr[0] == "" </span><span class="cov8" title="1">{
                slog.Debug("no lower bound was specified,so we set to lower min")
                lower = string(rune(0))
        }</span> else<span class="cov8" title="1"> {
                lower = splitStr[0]
        }</span>
        <span class="cov8" title="1">if splitStr[1] == "" </span><span class="cov8" title="1">{
                slog.Debug("no upper bound was specified, so we set to max")
                upper = string(rune(127))
        }</span> else<span class="cov8" title="1"> {
                upper = splitStr[1]
        }</span>

        <span class="cov8" title="1">return lower, upper</span>
}

// internal helper routines to validate inputs
// validateUrl is an internal routine that determines whether the uri is a valid uri.
func validateUrl(url string) error <span class="cov8" title="1">{
        if strings.Contains(url, "//") </span><span class="cov0" title="0">{
                return fmt.Errorf("malformed uri: //")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Package subscriptionManager provides functionality for managing collection-level subscribers
// and sending server-sent events (SSE) to subscribers based on changes in the collection.
package subscriptionManager

import (
        "context"
        "fmt"
        "github.com/RICE-COMP318-FALL24/owldb-p1group24/index_utils"
        "log/slog"
        "strconv"
        "time"
)

// internal data structure for each subscriber
type Colsubscriber struct {
        ch *chan []byte //the channel on which to send events
        lo string       //the lower bound
        hi string       //the upper bound
}

// IdToCSub defines an interface for managing collection-level subscribers.
// It provides methods to remove, upsert, and query subscribers.
type IdToCSub[id string, sub Colsubscriber] interface {
        Remove(key string) (removedChan sub, removed bool)                                        // Removes a subscriber by ID.
        Upsert(key string, check index_utils.UpdateCheck[id, sub]) (updated bool, err error)      // Upserts (inserts or updates) a subscriber.
        Query(ctx context.Context, low id, upper id) (res []index_utils.Pair[id, sub], err error) // Queries subscribers within an ID range.
}

// ColSubscriptionManager manages the subscribers to a collection and tracks their channels.
type ColSubscriptionManager struct {
        subs IdToCSub[string, Colsubscriber] //active subscribers to a collection
        //an internal id mapper
}

// NewColSubManager creates a new ColSubscriptionManager with the provided subscriber management system.
func NewColSubManager(subs IdToCSub[string, Colsubscriber]) *ColSubscriptionManager <span class="cov8" title="1">{
        return &amp;ColSubscriptionManager{
                subs: subs,
        }
}</span>

// AddSubscriber adds a subscriber to a collection. Returns the channel on which it will send
// all future events
func (c *ColSubscriptionManager) AddSubscriber(lo string, hi string) (subChan *chan []byte, id string) <span class="cov8" title="1">{
        ch := make(chan []byte)
        cs := Colsubscriber{ch: &amp;ch, lo: lo, hi: hi}

        check := func(key string, curV Colsubscriber, exists bool) (newV Colsubscriber, err error) </span><span class="cov8" title="1">{
                return cs, nil
        }</span>
        <span class="cov8" title="1">subId := generateResourceName()
        c.subs.Upsert(subId, check)

        return &amp;ch, subId</span>
}

// Notify will take a document name and event (as a series of bytes), notify every collection subscriber
// listening on a range that contains a document.
func (c *ColSubscriptionManager) Notify(docname string, evType string, payload []byte) <span class="cov8" title="1">{
        slog.Debug(fmt.Sprintf("Notifying subscribers using about an update to %s", docname))
        ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(10*time.Second))
        defer cancel()
        subs, _ := c.subs.Query(ctx, string(rune(0)), string(rune(127)))
        for _, v := range subs </span><span class="cov8" title="1">{
                lower, upper := v.Value.lo, v.Value.hi
                if lower &lt;= docname &amp;&amp; docname &lt;= upper </span><span class="cov8" title="1">{ //notify based on the ranges they are listening to
                        *v.Value.ch &lt;- c.GenerateEvent(evType, payload)
                }</span>

        }
}

// NotifyAll sends a "delete" event to all subscribers of a collection.
// It notifies every active subscriber regardless of their specific range.
func (c *ColSubscriptionManager) NotifyAll(colname string) <span class="cov0" title="0">{
        slog.Debug(fmt.Sprintf("Notifying subscribers using about an update to %s", colname))
        ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(10*time.Second))
        defer cancel()
        subs, _ := c.subs.Query(ctx, string(rune(0)), string(rune(127)))
        for _, v := range subs </span><span class="cov0" title="0">{

                //notify based on the ranges they are listening to
                *v.Value.ch &lt;- c.GenerateEvent("delete", []byte(colname))

        }</span>
}

// Remove removes a subscriber from the collection
// It closes the channel associated with the subscriber
func (c *ColSubscriptionManager) Remove(id string) <span class="cov0" title="0">{

        slog.Debug(fmt.Sprintf("Removing subscriber with id %s \n]]", id))
        _, removed := c.subs.Remove(id)
        if removed == false </span><span class="cov0" title="0">{
                slog.Warn(fmt.Sprintf("Warning: a removal of a subscriber was unsuccessful"))
                return
        }</span>

}

// GenerateEvent creates a formatted server-sent event (SSE) message.
// The event type can be "update" or "delete", and the event data is included in the payload.
func (c *ColSubscriptionManager) GenerateEvent(evType string, payload []byte) []byte <span class="cov8" title="1">{
        res := ""
        if evType == "update" </span><span class="cov8" title="1">{
                res += "event: update\n"
        }</span> else<span class="cov0" title="0"> if evType == "delete" </span><span class="cov0" title="0">{
                res += "event: delete\n"
        }</span>
        <span class="cov8" title="1">res += "data: " + string(payload) + "\n"
        res += "id: " + strconv.FormatInt(time.Now().UnixMilli(), 10)
        res += "\n\n"
        return []byte(res)</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package subscriptionManager

import (
        "fmt"
        "github.com/RICE-COMP318-FALL24/owldb-p1group24/index_utils"
        "log/slog"
)

type UriToDocs[uri string, docSubs *SubscriptionManager] interface {
        Upsert(key string, check index_utils.UpdateCheck[uri, docSubs]) (updated bool, err error) // Upserts (inserts or updates) a subscriber.
        Find(key string) (foundDsm *SubscriptionManager, found bool)
}

// Messager contains all active subscriptions
type Messager struct {
        idtosubfactory IdToSubFactory

        docSubs UriToDocs[string, *SubscriptionManager]
}

// IdToSubFactory is a factory function for
type IdToSubFactory func() IdToSub[string, *chan []byte]

func NewMessager(idtosubfactory IdToSubFactory, docsubs UriToDocs[string, *SubscriptionManager]) *Messager <span class="cov8" title="1">{
        return &amp;Messager{
                idtosubfactory: idtosubfactory,
                docSubs:        docsubs,
        }
}</span>

// AddDocSubscriber adds a subscriber to a resource located at uri. It returns the initial sse sent to the client,
// alongside a channel to listen on
func (m *Messager) AddDocSubscriber(uri string) (*chan []byte, string) <span class="cov8" title="1">{
        var resChan *chan []byte
        var id string
        slog.Debug(fmt.Sprintf("Adding a subscriber to the doc at uri %s", uri))
        check := func(uri string, curDsm *SubscriptionManager, exists bool) (newDsm *SubscriptionManager, err error) </span><span class="cov8" title="1">{
                if exists </span><span class="cov8" title="1">{

                        resChan, id = curDsm.AddSubscriber()
                        return curDsm, nil
                }</span> else<span class="cov8" title="1"> {

                        idtosub := m.idtosubfactory()
                        newDsm = New(idtosub)
                        resChan, id = newDsm.AddSubscriber()
                }</span>
                <span class="cov8" title="1">return newDsm, nil</span>
        }
        <span class="cov8" title="1">m.docSubs.Upsert(uri, check)
        return resChan, id</span>
}

// NotifyDocs notifies all subscribers to a document about an update
func (m *Messager) NotifyDocs(uri string, evtype string, payload []byte) <span class="cov8" title="1">{
        dsm, found := m.docSubs.Find(uri)

        if found </span><span class="cov8" title="1">{
                slog.Debug("Found, going to notify now!")
                dsm.Notify(evtype, payload)
        }</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Package subscriptionManager provides a system for managing subscribers and sending them server-sent events (SSE).
// It supports adding, removing, and notifying subscribers, as well as generating formatted SSE messages.
package subscriptionManager

import (
        "context"
        "fmt"
        "github.com/RICE-COMP318-FALL24/owldb-p1group24/index_utils"
        "log/slog"
        "math/rand/v2"
        "strconv"
        "time"
)

// IdToSub defines an interface for managing subscriber channels.
// It includes methods for finding, removing, and upserting subscribers, as well as querying a range of subscribers.
type IdToSub[id string, ch *chan []byte] interface {
        Find(key string) (foundValue ch, found bool)                                             // Find retrieves a subscriber by their ID.
        Remove(key string) (removedChan ch, removed bool)                                        // Remove deletes a subscriber by their ID.
        Upsert(key string, check index_utils.UpdateCheck[id, ch]) (updated bool, err error)      // Upsert inserts or updates a subscriber's channel.
        Query(ctx context.Context, low id, upper id) (res []index_utils.Pair[id, ch], err error) // Query retrieves subscribers within a range of IDs.
}

// New creates a new SubscriptionManager and initializes its subscriber management system.
func New(subs IdToSub[string, *chan []byte]) *SubscriptionManager <span class="cov8" title="1">{
        return &amp;SubscriptionManager{
                idCounter: 1,
                subs:      subs}
}</span>

// SubscriptionManager is responsible for managing subscribers and their channels.
// It tracks subscribers, allows for adding and removing them, and notifies them of events via SSE.
type SubscriptionManager struct {
        idCounter int                           // Tracks the next subscriber ID.
        subs      IdToSub[string, *chan []byte] // Manages the channels for subscribers.
}

// AddSubscriber adds a new subscriber to the subscription manager.
// It creates a new channel for the subscriber, assigns an ID, and returns the channel and ID.
func (s *SubscriptionManager) AddSubscriber() (*chan []byte, string) <span class="cov8" title="1">{
        slog.Debug(fmt.Sprintf("Current subscriber count is %d", s.idCounter))
        newCh := make(chan []byte)
        slog.Debug("Hello from s.Addsucrbiber")
        chk := func(key string, curV *chan []byte, exists bool) (ch *chan []byte, err error) </span><span class="cov8" title="1">{
                return &amp;newCh, nil
        }</span>

        <span class="cov8" title="1">id := generateResourceName()
        s.subs.Upsert(id, chk)

        slog.Debug(fmt.Sprintf("Current subscriber count is %d", s.idCounter))

        return &amp;newCh, id</span>
}

// RemoveSubscriber removes a subscriber with id id
// It closes the channel associated with the subscriber
func (s *SubscriptionManager) RemoveSubscriber(id string) <span class="cov8" title="1">{
        slog.Debug(fmt.Sprintf("Removing a subscriber whose id is %s", id))
        removedChan, _ := s.subs.Remove(id)

        ch := *removedChan
        close(ch)
}</span>

// Notify will send every subscriber an SSE of type evType, with payload byte
func (s *SubscriptionManager) Notify(evType string, payload []byte) <span class="cov8" title="1">{
        slog.Debug(fmt.Sprintf("DOCSUB MANAGER,payload is %s", string(payload)))
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()
        slog.Debug(fmt.Sprintf("Current sub counter is %d", s.idCounter))
        subscribers, _ := s.subs.Query(ctx, string(rune(0)), string(rune(127))) //we need to notify everyone

        for _, sub := range subscribers </span><span class="cov8" title="1">{
                slog.Debug("Notifying subscriber")
                v := sub.Value
                *v &lt;- s.GenerateEvent(evType, payload)

        }</span>
}

// GenerateEvent generates a formatted sse of type evtype, with payload payload
func (s *SubscriptionManager) GenerateEvent(evtype string, payload []byte) []byte <span class="cov8" title="1">{

        res := ""
        if evtype == "update" </span><span class="cov8" title="1">{
                res += "event: update\n"
        }</span> else<span class="cov8" title="1"> if evtype == "delete" </span><span class="cov8" title="1">{
                res += "event: delete\n"
        }</span>
        <span class="cov8" title="1">res += "data: " + string(payload) + "\n"
        res += "id: " + strconv.FormatInt(time.Now().UnixMilli(), 10)
        res += "\n\n"
        return []byte(res)</span>
}

// generateResourceName is an internal routine to generate the name of a resource
func generateResourceName() string <span class="cov8" title="1">{
        var name string
        validChars := "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-.~"
        leng := 12
        for i := 0; i &lt; leng; i++ </span><span class="cov8" title="1">{
                ch := rand.IntN(len(validChars))
                name += string(validChars[ch])
        }</span>
        <span class="cov8" title="1">return name</span>

}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Description: This file contains the implementation of the Validator struct,
// which is used to validate JSON data against a JSON schema.
package validation

import (
        "encoding/json"
        "fmt"
        "log/slog"

        "github.com/santhosh-tekuri/jsonschema/v5"
)

// Validator holds a compiled JSON schema for validation

type Validator struct {
        schema *jsonschema.Schema
}

// New creates a new instance of Validator by compiling the provided JSON schema file.
// Inputs:
//   - jsonSchemaFilename: The filename of the JSON schema file to compile.
//
// Returns:
//   - A new instance of Validator if the schema is successfully compiled.
func New(jsonSchemaFilename string) (*Validator, error) <span class="cov8" title="1">{

        compiler := jsonschema.NewCompiler()
        //compiler.Draft = jsonschema.Draft2020 // Specify the JSON Schema draft version if needed

        // Compile the schema
        schema, err := compiler.Compile(jsonSchemaFilename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error compiling schema '%s': %w", jsonSchemaFilename, err)
        }</span>

        <span class="cov8" title="1">return &amp;Validator{schema: schema}, nil</span>
}

// Validate checks whether the provided JSON data conforms to the compiled schema.
// Inputs:
//   - jsonData: Byte slice representing the JSON data to validate.
//
// Returns:
//   - An error if the JSON data is invalid or does not conform to the schema.
//   - nil if the JSON data is valid.
func (v *Validator) Validate(jsonData []byte) error <span class="cov8" title="1">{
        var jsonObject interface{}

        if err := json.Unmarshal(jsonData, &amp;jsonObject); err != nil </span><span class="cov0" title="0">{
                slog.Error("Unable to unmarshal JSON data", "error", err)
                return fmt.Errorf("unable to unmarshal JSON data: %w", err)
        }</span>

        <span class="cov8" title="1">if err := v.schema.Validate(jsonObject); err != nil </span><span class="cov8" title="1">{
                slog.Error("JSON validation failed", "error", err)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
